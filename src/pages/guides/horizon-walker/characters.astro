---
import { Image } from 'astro:assets';
import CharacterLayout from '../../../layouts/horizon-walker/CharacterLayout.astro';
import Breadcrumb from '../../../components/horizon-walker/Breadcrumb.astro';
import {
  HORIZON_WALKER_CHARACTERS,
  gameInfo,
  getTagCategory,
} from '../../../data/horizon-walker/characters.js';

// Extract filter options from enhanced data structure
const { rarities } = gameInfo;

// Breadcrumb data for SEO
const breadcrumbs = [
  { name: 'Home', href: '/' },
  { name: 'Horizon Walker', href: '/guides/horizon-walker/' },
  { name: 'Characters' },
];

// Calculate enhanced stats for display
const totalCharacters = HORIZON_WALKER_CHARACTERS.length;
const exCount = HORIZON_WALKER_CHARACTERS.filter(char => char.rarity === 'EX').length;
const ssCount = HORIZON_WALKER_CHARACTERS.filter(char => char.rarity === 'SS').length;
const sCount = HORIZON_WALKER_CHARACTERS.filter(char => char.rarity === 'S').length;
const aCount = HORIZON_WALKER_CHARACTERS.filter(char => char.rarity === 'A').length;
const bCount = HORIZON_WALKER_CHARACTERS.filter(char => char.rarity === 'B').length;

// SEO metadata
const title = 'Horizon Walker Characters Database - All Heroes & Waifus List 2025 | GachaWiki';
const description = `Explore all ${totalCharacters} Horizon Walker characters including ${exCount} EX, ${ssCount} SS, ${sCount} S, ${aCount} A, ${bCount} B rarity heroes. Complete database with stats, costs, classes, elements, and factions. Advanced filtering and mobile-optimized interface.`;
---

<CharacterLayout
  title={title}
  description={description}
  gameTitle="Character Database"
  showBackButton={false}
>
  <!-- Breadcrumb Navigation -->
  <Breadcrumb items={breadcrumbs} />

  <section class="hw-char-db-page-flex">
    <div class="hw-char-db-main-content">
      <div class="hw-char-db-content-wrapper">
        <!-- Enhanced filter bar with integrated stats -->
        <div class="filter-bar">
          <!-- Controls Section -->
          <div class="filter-controls-section">
            <!-- Stats Info Row -->
            <div class="filter-stats-row">
              <div class="stats-info-section">
                <p class="hw-char-db-subtitle">
                  All stats shown at max level (Level {gameInfo.maxLevel})
                </p>

                <!-- Character rarity stats -->
                <div class="hw-char-db-stats-summary">
                  <span class="hw-badge" data-rarity="EX">{exCount} EX</span>
                  <span class="hw-badge" data-rarity="SS">{ssCount} SS</span>
                  <span class="hw-badge" data-rarity="S">{sCount} S</span>
                  <span class="hw-badge" data-rarity="A">{aCount} A</span>
                  <span class="hw-badge" data-rarity="B">{bCount} B</span>
                </div>
              </div>
            </div>

            <!-- Reset Row -->
            <div class="filter-reset-row">
              <button type="button" id="reset-table" class="reset-button"> Reset All </button>
            </div>

            <!-- Filters Left, Sorting Right -->
            <div class="filter-controls-row">
              <div class="filter-left-section">
                <div class="filter-section">
                  <label class="filter-label" for="rarity-filter">Filter by Rarity</label>
                  <select
                    id="rarity-filter"
                    class="filter-select"
                    data-filter="rarity"
                    class="touch-optimized"
                  >
                    <option value="">All Rarities</option>
                    {rarities.map(rarity => <option value={rarity}>{rarity}</option>)}
                  </select>
                </div>
              </div>

              <div class="sort-right-section">
                <label class="filter-label">Sort by</label>
                <div class="sort-buttons-single-row">
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="cost"
                    class="touch-optimized"
                  >
                    Cost <span class="sort-indicator"></span>
                  </button>
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="strength"
                    class="touch-optimized"
                  >
                    STR <span class="sort-indicator"></span>
                  </button>
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="intelligence"
                    class="touch-optimized"
                  >
                    INT <span class="sort-indicator"></span>
                  </button>
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="vitality"
                    class="touch-optimized"
                  >
                    VIT <span class="sort-indicator"></span>
                  </button>
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="agility"
                    class="touch-optimized"
                  >
                    AGI <span class="sort-indicator"></span>
                  </button>
                  <button
                    class="sort-btn sort-btn--compact"
                    data-sort="technic"
                    class="touch-optimized"
                  >
                    TEC <span class="sort-indicator"></span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Desktop table container with touch optimizations -->
        <div class="character-table-container">
          <table class="character-table" id="character-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Image</th>
                <th>Name</th>
                <th>Rarity</th>
                <th>Cost</th>
                <th>STR</th>
                <th>INT</th>
                <th>VIT</th>
                <th>AGI</th>
                <th>TEC</th>
              </tr>
            </thead>
            <tbody id="character-table-body">
              {
                HORIZON_WALKER_CHARACTERS.map((character, idx) => (
                  <tr
                    data-character-id={character.id}
                    data-url={character.detailUrl}
                    data-name={character.name}
                    data-rarity={character.rarity}
                    data-class={character.class}
                    data-element={character.element}
                    data-faction={character.faction}
                    data-tags={character.tags ? character.tags.join(', ') : ''}
                    class="clickable-row"
                  >
                    <td>{idx + 1}</td>
                    <td>
                      <div class="desktop-character-image">
                        <Image
                          src={character.image}
                          alt={character.name}
                          class="character-img"
                          width={80}
                          height={80}
                          loading="lazy"
                        />
                      </div>
                    </td>
                    <td>
                      <span class="character-name">{character.name}</span>
                    </td>
                    <td>
                      <span class="hw-badge" data-rarity={character.rarity} data-sort-key="rarity">
                        {character.rarity}
                      </span>
                    </td>
                    <td data-sort-key="cost">
                      <span class="cost-value">{character.cost}</span>
                    </td>
                    <td data-sort-key="strength">
                      <span class="stat-value">{character.stats.strength}</span>
                    </td>
                    <td data-sort-key="intelligence">
                      <span class="stat-value">{character.stats.intelligence}</span>
                    </td>
                    <td data-sort-key="vitality">
                      <span class="stat-value">{character.stats.vitality}</span>
                    </td>
                    <td data-sort-key="agility">
                      <span class="stat-value">{character.stats.agility}</span>
                    </td>
                    <td data-sort-key="technic">
                      <span class="stat-value">{character.stats.technic}</span>
                    </td>
                  </tr>
                ))
              }
            </tbody>
          </table>
        </div>

        <!-- Mobile card view container with touch optimization -->
        <div class="mobile-card-view" id="mobile-cards-container">
          {
            HORIZON_WALKER_CHARACTERS.map(char => (
              <div
                class="mobile-character-card"
                data-character-id={char.id}
                data-slug={char.slug}
                data-url={char.detailUrl}
                data-name={char.name}
                data-rarity={char.rarity}
                data-class={char.class}
                data-element={char.element}
                data-faction={char.faction}
                data-tags={char.tags ? char.tags.join(', ') : ''}
                style="cursor:pointer; touch-action: manipulation;"
              >
                {/* Clean header section - image, name, rarity all together */}
                <div class="mobile-card-header">
                  <div class="mobile-card-image">
                    <div class="mobile-character-image">
                      <img
                        src={char.image}
                        alt={char.name}
                        class="character-img"
                        width="64"
                        height="64"
                        loading="lazy"
                      />
                    </div>
                  </div>
                  <div class="mobile-card-info">
                    <h3 class="character-name">{char.name}</h3>
                    <div class="header-badges">
                      <span class="hw-badge" data-rarity={char.rarity}>
                        {char.rarity}
                      </span>
                      <span class="cost-badge" data-type="Cost">
                        Cost: {char.cost}
                      </span>
                    </div>
                  </div>
                </div>

                {/* Clean stats grid - 5 basic stats */}
                <div class="mobile-card-stats-grid">
                  <div class="stat-item">
                    <span class="stat-label">STR</span>
                    <span class="stat-value" data-stat="strength">
                      {char.stats.strength}
                    </span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">INT</span>
                    <span class="stat-value" data-stat="intelligence">
                      {char.stats.intelligence}
                    </span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">VIT</span>
                    <span class="stat-value" data-stat="vitality">
                      {char.stats.vitality}
                    </span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">AGI</span>
                    <span class="stat-value" data-stat="agility">
                      {char.stats.agility}
                    </span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">TEC</span>
                    <span class="stat-value" data-stat="technic">
                      {char.stats.technic}
                    </span>
                  </div>
                </div>

                {/* Gameplay Tags with categorization */}
                {char.tags && char.tags.length > 0 && (
                  <div class="mobile-card-tags">
                    <div class="tags-label">Gameplay Tags:</div>
                    <div class="tags-container">
                      {char.tags.map(tag => (
                        <span class={`character-tag ${getTagCategory(tag)}`}>{tag}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ))
          }
        </div>
      </div>
    </div>
  </section>

  <!-- Initialize enhanced database utilities -->
  <script>
    // Consolidated Horizon Walker Character Database JavaScript
    // Handles filtering, sorting, and interaction logic for the character database

    // TypeScript interfaces for better type safety
    interface CharacterStats {
      meleeAtk: number;
      rangedAtk: number;
      magicAtk: number;
      maxHp: number;
      spd: number;
      startingAp: number;
      apRecovery: number;
      accuracy: number;
      evade: number;
      critRate: number;
      critDmg: number;
      technic: number;
      strength: number;
      intelligence: number;
      vitality: number;
      agility: number;
    }

    interface Character {
      id: number;
      name: string;
      rarity: 'EX' | 'SS' | 'S' | 'A' | 'B';
      cost: number;
      class: string;
      element: string;
      faction: string;
      role: string;
      tags: string[];
      stats: CharacterStats;
      image: string;
      slug: string;
      detailUrl: string;
    }

    interface SortState {
      key: string;
      direction: 'asc' | 'desc';
    }

    interface FilterState {
      rarity: string | null;
    }

    // Function to initialize - run immediately or when DOM is ready
    const initialize = (): void => {
      // --- DOM references ---
      const tableBody = document.getElementById('character-table-body');
      const mobileCardsContainer = document.getElementById('mobile-cards-container');
      const rarityFilter = document.getElementById('rarity-filter');
      const sortButtons = document.querySelectorAll('.sort-btn');
      const resetButton = document.getElementById('reset-table');

      // --- State ---
      let currentSortKey = 'name';
      let currentSortDirection = 'asc';

      // Sort button states: normal -> asc -> desc -> normal (3-state cycle)
      const filterStates = new Map();

      // Early exit if required elements don't exist
      if (!tableBody || !mobileCardsContainer) {
        return;
      }

      // --- Helper Functions ---

      /**
       * Renumbers visible table rows sequentially
       * Used after filtering to maintain proper row numbering
       */
      function renumberRows(): void {
        let visibleIndex = 1;
        Array.from(tableBody!.children).forEach((row: Element) => {
          if ((row as HTMLElement).style.display !== 'none') {
            const firstCell = row.querySelector('td');
            if (firstCell) {
              firstCell.textContent = String(visibleIndex++);
            }
          }
        });
      }

      /**
       * Sorts elements numerically by specified criteria
       * @param items - Array of DOM elements to sort
       * @param columnIndex - Table column index for desktop sorting
       * @param isDesktop - Whether sorting desktop table or mobile cards
       * @returns Sorted array of elements
       */
      function sortByNumeric(
        items: Element[],
        columnIndex: number,
        isDesktop: boolean = true
      ): Element[] {
        return items.sort((a: Element, b: Element) => {
          let valueA: number, valueB: number;

          if (isDesktop) {
            const cellA = a.querySelector(`td:nth-child(${columnIndex})`);
            const cellB = b.querySelector(`td:nth-child(${columnIndex})`);
            valueA = parseFloat((cellA?.textContent || '0').replace(/[,%]/g, ''));
            valueB = parseFloat((cellB?.textContent || '0').replace(/[,%]/g, ''));
          } else {
            // Mobile cards - need to find the corresponding stat
            const statLabelA = a.querySelector(`[data-stat="${currentSortKey}"]`);
            const statLabelB = b.querySelector(`[data-stat="${currentSortKey}"]`);
            valueA = parseFloat((statLabelA?.textContent || '0').replace(/[,%]/g, ''));
            valueB = parseFloat((statLabelB?.textContent || '0').replace(/[,%]/g, ''));
          }

          return currentSortDirection === 'desc' ? valueB - valueA : valueA - valueB;
        });
      }

      /**
       * Applies sorting to both desktop table and mobile cards
       * @param sortKey - The data attribute key to sort by
       */
      function applySort(sortKey: string): void {
        currentSortKey = sortKey;

        // Sort desktop table
        if (tableBody) {
          const rows = Array.from(tableBody.children);
          let sortedRows: Element[];

          if (sortKey === 'name') {
            // Name sorting removed - skip
            sortedRows = rows;
          } else {
            // Find column index for numeric sorting
            const headerRow = tableBody.parentElement?.querySelector('thead tr');
            const columnIndex =
              Array.from(headerRow?.children || []).findIndex(th =>
                th.textContent.toLowerCase().includes(sortKey.toLowerCase())
              ) + 1;

            if (columnIndex > 0) {
              sortedRows = sortByNumeric(rows, columnIndex, true);
            } else {
              sortedRows = rows;
            }
          }

          // Re-append sorted rows
          sortedRows.forEach((row: Element) => tableBody.appendChild(row));
          renumberRows();
        }

        // Sort mobile cards
        if (mobileCardsContainer) {
          const cards = Array.from(mobileCardsContainer.children);
          let sortedCards: Element[];

          if (sortKey === 'name') {
            // Name sorting for mobile cards - simple alphabetical
            sortedCards = cards.sort((a: Element, b: Element) => {
              const nameA = a.querySelector('.character-name')?.textContent || '';
              const nameB = b.querySelector('.character-name')?.textContent || '';
              return currentSortDirection === 'desc'
                ? nameB.localeCompare(nameA)
                : nameA.localeCompare(nameB);
            });
          } else {
            sortedCards = sortByNumeric(cards, 0, false);
          }

          // Re-append sorted cards
          sortedCards.forEach((card: Element) => mobileCardsContainer.appendChild(card));
        }

        // Save sort state to sessionStorage
        try {
          sessionStorage.setItem(
            'hw-character-sort',
            JSON.stringify({
              key: currentSortKey,
              direction: currentSortDirection,
            })
          );
        } catch (error) {
          // Ignore storage errors
        }
      }

      /**
       * Applies current filter settings to both desktop and mobile views
       * Filters by rarity and saves state to sessionStorage
       */
      function applyFilters(): void {
        const rarityValue = (rarityFilter as HTMLSelectElement)?.value || '';

        // Filter desktop table rows
        if (tableBody) {
          Array.from(tableBody.children).forEach((row: Element) => {
            const rarityCell = row.querySelector('.hw-badge[data-rarity]');

            const matchesRarity = !rarityValue || rarityCell?.textContent.trim() === rarityValue;

            const isVisible = matchesRarity;
            (row as HTMLElement).style.display = isVisible ? '' : 'none';
          });

          renumberRows();
        }

        // Filter mobile cards
        if (mobileCardsContainer) {
          Array.from(mobileCardsContainer.children).forEach((card: Element) => {
            const rarityBadge = card.querySelector('.hw-badge[data-rarity]');

            const matchesRarity = !rarityValue || rarityBadge?.textContent.trim() === rarityValue;

            const isVisible = matchesRarity;
            (card as HTMLElement).style.display = isVisible ? '' : 'none';
          });
        }

        // Save filter state to sessionStorage
        const filterState = {
          rarity: rarityValue || null,
        };

        const activeFilters = {};
        Object.keys(filterState).forEach(key => {
          if (filterState[key]) {
            activeFilters[key] = filterState[key];
          }
        });

        try {
          if (Object.keys(activeFilters).length > 0) {
            sessionStorage.setItem('hw-character-filters', JSON.stringify(activeFilters));
          } else {
            sessionStorage.removeItem('hw-character-filters');
          }
        } catch (error) {
          // Ignore storage errors
        }
      }

      /**
       * Resets all filters and sorting to default state
       * Clears sessionStorage and shows all characters
       */
      function resetDatabase(): void {
        // Clear all filters
        if (rarityFilter) (rarityFilter as HTMLSelectElement).value = '';

        // Show all rows and cards
        if (tableBody) {
          Array.from(tableBody.children).forEach((row: Element) => {
            (row as HTMLElement).style.display = '';
          });
          renumberRows();
        }

        if (mobileCardsContainer) {
          Array.from(mobileCardsContainer.children).forEach((card: Element) => {
            (card as HTMLElement).style.display = '';
          });
        }

        // Clear active sort buttons
        sortButtons.forEach(btn => btn.classList.remove('active'));

        // Clear sessionStorage
        try {
          sessionStorage.removeItem('hw-character-filters');
          sessionStorage.removeItem('hw-character-sort');
        } catch (error) {
          // Ignore storage errors
        }

        currentSortKey = 'name';
        currentSortDirection = 'asc';
      }

      function restoreState(): void {
        // Restore filter state
        try {
          const savedFilters = sessionStorage.getItem('hw-character-filters');
          if (savedFilters) {
            const filters = JSON.parse(savedFilters);
            if (filters.rarity && rarityFilter)
              (rarityFilter as HTMLSelectElement).value = filters.rarity;
            applyFilters();
          }
        } catch (error) {
          // Ignore storage errors
        }

        // Restore sort state
        try {
          const savedSort = sessionStorage.getItem('hw-character-sort');
          if (savedSort) {
            const sortState = JSON.parse(savedSort);
            currentSortKey = sortState.key || 'name';
            currentSortDirection = sortState.direction || 'asc';

            const activeButton = document.querySelector(`[data-sort="${currentSortKey}"]`);
            if (activeButton) {
              activeButton.classList.add('active');
              applySort(currentSortKey);
            }
          }
        } catch (error) {
          // Ignore storage errors
        }
      }

      // --- Three-State Sort Button Functions ---
      function initializeSortStates(): void {
        sortButtons.forEach(btn => {
          filterStates.set(btn, 'normal');
          btn.classList.add('state-normal');
        });
      }

      function cycleSortState(sortButton: HTMLElement): void {
        const currentState = filterStates.get(sortButton);
        let nextState: string;

        switch (currentState) {
          case 'normal':
            nextState = 'asc';
            break;
          case 'asc':
            nextState = 'desc';
            break;
          case 'desc':
            nextState = 'normal';
            break;
          default:
            nextState = 'normal';
        }

        // Reset all other sort buttons to normal
        sortButtons.forEach(btn => {
          if (btn !== sortButton) {
            btn.classList.remove('state-normal', 'state-asc', 'state-desc', 'active');
            btn.classList.add('state-normal');
            filterStates.set(btn, 'normal');
          }
        });

        // Update clicked button state
        sortButton.classList.remove('state-normal', 'state-asc', 'state-desc', 'active');
        sortButton.classList.add(`state-${nextState}`);
        filterStates.set(sortButton, nextState);

        // Apply sorting based on new state
        if (nextState !== 'normal') {
          const sortKey = sortButton.dataset.sort;
          if (sortKey) {
            currentSortKey = sortKey;
            currentSortDirection = nextState; // 'asc' or 'desc'
            applySort(sortKey);
          }
        }
      }

      // --- Event Listeners ---

      // Initialize sort button states
      initializeSortStates();

      // Filter event listeners (keep existing for compatibility)
      if (rarityFilter) {
        rarityFilter.addEventListener('change', applyFilters);
      }

      // Three-state sort button event listeners
      sortButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          cycleSortState(btn as HTMLElement);
        });
      });

      // Reset button event listener
      if (resetButton) {
        resetButton.addEventListener('click', resetDatabase);
      }

      // Character card/row click navigation with touch optimization
      // Use event delegation to handle both existing and future elements
      document.addEventListener('click', e => {
        const clickableElement = (e.target as Element)?.closest('[data-url]');
        if (clickableElement) {
          e.preventDefault();
          const url = (clickableElement as HTMLElement).dataset.url;
          if (url) {
            window.location.href = url;
          }
        }
      });

      // Also set styles for existing elements
      const clickableElements = document.querySelectorAll('[data-url]');
      clickableElements.forEach(element => {
        (element as HTMLElement).style.cursor = 'pointer';
        (element as HTMLElement).style.touchAction = 'manipulation';
      });

      // Initialize with restored state
      restoreState();
    };

    // Run initialization - either immediately if DOM is ready, or wait for it
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
  </script>
</CharacterLayout>
