---
import CharacterBuildIndividualLayout from '../../../../layouts/zone-nova/CharacterBuildIndividualLayout.astro';
import ZNCharacterImage from '../../../../components/zone-nova/ZNCharacterImage.astro';
import ZNClassImage from '../../../../components/zone-nova/ZNClassImage.astro';
import ZNMemoryImage from '../../../../components/zone-nova/ZNMemoryImage.astro';
import ZNRuneSetDisplay from '../../../../components/zone-nova/ZRuneSetDisplay.astro';
import ZNRunesImage from '../../../../components/zone-nova/ZNRunesImage.astro';
import { ALL_CHARACTER_BUILDS } from '../../../../data/zone-nova/character-builds.js';
import { getCharacterBySlug } from '../../../../data/zone-nova/characters.js';
import { apepData } from '../../../../data/zone-nova/characters/apep.js';
import { helaData } from '../../../../data/zone-nova/characters/hela.js';
import { naiyaData } from '../../../../data/zone-nova/characters/naiya.js';
import { pennyData } from '../../../../data/zone-nova/characters/penny.js';
import { apolloData } from '../../../../data/zone-nova/characters/apollo.js';
import { gaiaData } from '../../../../data/zone-nova/characters/gaia.js';
import { morganLeFayData } from '../../../../data/zone-nova/characters/morgan-le-fay.js';
import { guinevereData } from '../../../../data/zone-nova/characters/guinevere.js';
import { artemisData } from '../../../../data/zone-nova/characters/artemis.js';
import { freyeData } from '../../../../data/zone-nova/characters/freye.js';
import { ibarakiDojiData } from '../../../../data/zone-nova/characters/ibaraki-doji.js';
import { sigurdData } from '../../../../data/zone-nova/characters/sigurd.js';

export const prerender = true;

// Generate static paths for all available character builds
export async function getStaticPaths() {
  const builds = Object.values(ALL_CHARACTER_BUILDS);

  return builds.map(build => ({
    params: { character_name: build.character?.slug || 'apep' },
    props: {
      character: build.character,
      build: build,
    },
  }));
}

// Get the character slug from the URL
const { character_name } = Astro.params;

// Get character data and build data from props (from getStaticPaths)
const { character, build } = Astro.props;

// Get fallback data if character or build not found
const fallbackCharacter = {
  name: character_name,
  class: 'Unknown',
  role: 'Unknown',
  faction: 'Unknown',
  element: 'Unknown',
  rarity: 'Unknown',
  image: null,
};

const fallbackBuild = {
  name: character_name,
  role: 'DPS',
  buildType: 'Basic Build',
  description: 'Build information is not available for this character yet.',
  skillPriority: [],
  recommendedMemoryCards: [],
  alternativeMemoryCards: [],
  runes: { primary: 'Attack', secondary: 'HP', stats: [] },
  teamSynergy: { goodWith: [], description: '' },
  tips: ['Build information coming soon.'],
};

const finalCharacter = character || fallbackCharacter;
const finalBuild = build || fallbackBuild;

// Get character-specific data for Apep, Hela, Naiya, Penny, Apollo, Morgan Le Fay, Guinevere, Artemis, and Freye
const characterData =
  finalCharacter.slug === 'apep'
    ? apepData
    : finalCharacter.slug === 'hela'
      ? helaData
      : finalCharacter.slug === 'naiya'
        ? naiyaData
        : finalCharacter.slug === 'penny'
          ? pennyData
          : finalCharacter.slug === 'apollo'
            ? apolloData
            : finalCharacter.slug === 'gaia'
              ? gaiaData
              : finalCharacter.slug === 'morgan-le-fay'
                ? morganLeFayData
                : finalCharacter.slug === 'guinevere'
                  ? guinevereData
                  : finalCharacter.slug === 'artemis'
                    ? artemisData
                    : finalCharacter.slug === 'freye'
                      ? freyeData
                      : finalCharacter.slug === 'ibaraki-doji'
                        ? ibarakiDojiData
                        : finalCharacter.slug === 'sigurd'
                          ? sigurdData
                          : null;

// Memory card URL mapping for easy maintenance
const memoryCardUrls = {
  // Character-specific memory cards
  'The Beauty of Heijing Castle': '/guides/zone-nova/memories/the-beauty-of-heijing-castle/',
  'A Smile That Topples Cities': '/guides/zone-nova/memories/a-smile-that-topples-cities/',
  'Solitary Realm': '/guides/zone-nova/memories/solitary-realm/',
  'Strange Gaze Full of Desire': '/guides/zone-nova/memories/strange-gaze-full-of-desire/',
  'Frost Dominion': '/guides/zone-nova/memories/frost-dominion/',
  'Embarrassing Pattern': '/guides/zone-nova/memories/embarrassing-pattern/',
  'Her Trainer': '/guides/zone-nova/memories/her-trainer/',
  'Wrong Appearance Timing': '/guides/zone-nova/memories/wrong-appearance-timing/',
  'The Loneliest Moment': '/guides/zone-nova/memories/the-loneliest-moment/',
  'Absolutely Perfect Arms': '/guides/zone-nova/memories/absolutely-perfect-arms/',
  'Night Assault Suspect': '/guides/zone-nova/memories/night-assault-suspect/',
  "Slave's Original Wish": '/guides/zone-nova/memories/slaves-original-wish/',
  'Cute Little Thing': '/guides/zone-nova/memories/cute-little-thing/',
  'Battlefield Flower': '/guides/zone-nova/memories/battlefield-flower/',
  'Deceptive Ultimate Temptation': '/guides/zone-nova/memories/deceptive-ultimate-temptation/',
  'True Order (真正的秩序)': '/guides/zone-nova/memories/true-order/',
  'Shared Bath Time': '/guides/zone-nova/memories/shared-bath-time/',
  'Simple Birdcage': '/guides/zone-nova/memories/simple-birdcage/',

  'Hera Memory': '/guides/zone-nova/memories/black-face-ugly-person/',
  'Secret Room Reality': '/guides/zone-nova/memories/secret-room-reality/',

  // Alternative memory cards
  'Lancelot-HerTrainer': '/guides/zone-nova/memories/lancelot-hertrainer/',
  'Sister Penny Trying on New Clothes':
    '/guides/zone-nova/memories/sister-penny-trying-on-new-clothes/',
  'Sleep Treasure': '/guides/zone-nova/memories/sleep-treasure/',
  Mordred: '/guides/zone-nova/memories/mordred/',
  'Heroes, Never Stop': '/guides/zone-nova/memories/heroes-never-stop/',
  'Behind the Regret': '/guides/zone-nova/memories/behind-the-regret/',
  'Morning Sunlight': '/guides/zone-nova/memories/morning-sunlight/',
  'During Military Academy Training':
    '/guides/zone-nova/memories/during-military-academy-training/',

  // Artemis memory cards
  'Halloween Candy': '/guides/zone-nova/memories/halloween-candy/',
  'The World Seems to Have Stopped': '/guides/zone-nova/memories/the-world-seems-to-have-stopped/',

  // Freye memory cards
  'Lamplight Study': '/guides/zone-nova/memories/lamplight-study/',
  'Sleepy Guardian': '/guides/zone-nova/memories/sleepy-guardian/',

  // Ibaraki-doji memory cards
  'A Perfect Makeup Look?': '/guides/zone-nova/memories/a-perfect-makeup-look/',
};

// Helper function to get badge class names
function getElementBadgeClass(element) {
  return `element-badge ${element?.toLowerCase() || 'unknown'}`;
}

function getRarityBadgeClass(rarity) {
  return `rarity-badge ${rarity?.toLowerCase() || 'unknown'}`;
}

// Generate page title
const pageTitle = `${finalCharacter.name} Build Guide - Zone Nova`;
const pageDescription = `Complete build guide for ${finalCharacter.name} in Zone Nova. Optimal equipment, skill priorities, memory cards, and team compositions.`;
---

<CharacterBuildIndividualLayout
  title={pageTitle}
  description={pageDescription}
  gameTitle={`${finalCharacter.name} Build Guide`}
  character={finalCharacter}
>
  <!-- Build Overview Section -->
  <section class="build-overview">
    <div class="build-overview-header">
      <div class="build-character-portrait">
        <ZNCharacterImage
          imageName={finalCharacter.image || 'Apep.jpg'}
          alt={`${finalCharacter.name} portrait`}
          width={100}
          height={100}
          loading="eager"
        />
      </div>

      <div class="build-character-info">
        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
          <h1>{finalCharacter.name}</h1>
          <ZNClassImage
            className={finalCharacter.class || 'Warrior'}
            alt={`${finalCharacter.class || 'Warrior'} class icon`}
            size="medium"
          />
        </div>
        <div class="build-character-faction">{finalCharacter.faction}</div>
      </div>
    </div>

    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem;">
      <span class={getRarityBadgeClass(finalCharacter.rarity)}>
        {finalCharacter.rarity}
      </span>
      <span class={getElementBadgeClass(finalCharacter.element)}>
        {finalCharacter.element}
      </span>
      <span
        class={`class-badge ${finalCharacter.class?.toLowerCase().replace(' ', '-') || 'unknown'}`}
      >
        {finalCharacter.class}
      </span>
      <span class={`role-badge ${finalCharacter.role?.toLowerCase() || 'unknown'}`}>
        {finalCharacter.role}
      </span>
    </div>

    <p style="color: var(--zn-text-primary); font-size: 1.1rem; line-height: 1.6;">
      {finalBuild.description}
    </p>
  </section>

  <!-- Skill Priority Section -->
  <section class="build-section">
    <h2>Skill Priority</h2>
    <p style="color: var(--zn-text-secondary); margin-bottom: 1.5rem;">
      Skill level recommendations for F2P non-spender:
    </p>

    <div class="skill-priority-list">
      {
        finalBuild.skillPriority.map((skill, index) => {
          // Get real skill description from apep.js if available
          let skillDescription = skill.description;
          if (characterData && characterData.skills) {
            const skillKey = skill.skill.toLowerCase().replace(' ', '');
            let specificSkill: any = null;

            if (skillKey === 'passive') {
              specificSkill = characterData.skills.passive;
            } else if (skillKey === 'autoskill') {
              specificSkill = characterData.skills.auto;
            } else if (skillKey === 'ultimate') {
              specificSkill = characterData.skills.ultimate;
            } else if (skillKey === 'normalattack') {
              specificSkill = characterData.skills.normal;
            }

            if (specificSkill) {
              skillDescription = specificSkill.description;
              // Prepend Energy Cost or Cooldown if available
              if (specificSkill.energyCost) {
                skillDescription = `Energy Cost: ${specificSkill.energyCost}\n${skillDescription}`;
              }
              if (specificSkill.cooldown) {
                skillDescription = `Auto-trigger: ${specificSkill.cooldown}\n${skillDescription}`;
              }
            }
          }

          return (
            <div class="skill-priority-item">
              <div class="skill-priority-number">{skill.priority}</div>
              <div class="skill-priority-info">
                <div class="skill-priority-name">{skill.skill}</div>
                <div class="skill-priority-level">{skill.level}</div>
                <div class="skill-priority-description" style="white-space: pre-line;">
                  {skillDescription}
                </div>
              </div>
            </div>
          );
        })
      }
    </div>
  </section>

  <!-- Recommended Memory Cards Section -->
  <section class="build-section">
    <h2>Recommended Memory Cards</h2>
    <p style="color: var(--zn-text-secondary); margin-bottom: 1.5rem;">
      These are the best memory cards for {finalCharacter.name}:
    </p>

    <div class="memory-cards-grid">
      {
        finalBuild.recommendedMemoryCards.map(card => {
          // Get real memory card data if it's Apep's own card
          type MemoryCardData = {
            name: string;
            image: string;
            description?: string;
            stats: {
              hp: string;
              attack: string;
              defense: string;
            };
            effects: string[];
          };

          let memoryDetails: MemoryCardData | null = null;
          if (characterData && characterData.memoryCard && card.characterSpecific) {
            memoryDetails = characterData.memoryCard as MemoryCardData;
          } else if (card.memoryImage && card.memoryStats) {
            memoryDetails = {
              name: card.name,
              image: card.memoryImage,
              stats: card.memoryStats,
              description: card.description,
              effects: card.effects || [],
            } as MemoryCardData;
          }

          return (
            <div class={`memory-card-item ${card.characterSpecific ? 'character-specific' : ''}`}>
              <div class="memory-card-horizontal">
                {memoryDetails && (
                  <div class="memory-card-image-container">
                    <ZNMemoryImage
                      imageName={memoryDetails.image}
                      alt={`${card.name} memory card`}
                      width={60}
                      height={60}
                      loading="eager"
                    />
                  </div>
                )}
                <div class="memory-card-content">
                  <div class="memory-card-header">
                    <div class="memory-card-name">
                      {card.name}
                      {card.characterSpecific && (
                        <span class="memory-card-exclusive">★ Exclusive</span>
                      )}
                    </div>
                    {card.priority && (
                      <div>
                        <span
                          class={`memory-card-badge ${card.priority === 'Highly Recommended' ? 'highly-recommended' : card.priority.toLowerCase()}`}
                        >
                          {card.priority}
                        </span>
                      </div>
                    )}
                  </div>
                  <div class="memory-card-effect">{card.description || card.effect}</div>

                  {/* Spending recommendation note */}
                  {card.spendingNote && (
                    <div class="memory-card-spending-note">
                      <span class="note-title">Note:</span>
                      <span class="note-content">{card.spendingNote}</span>
                    </div>
                  )}

                  {/* General note */}
                  {card.note && (
                    <div class="memory-card-spending-note">
                      <span class="note-title">Note:</span>
                      <span class="note-content">{card.note}</span>
                    </div>
                  )}

                  {memoryDetails && (
                    <div class="memory-card-stats">
                      <strong>Stats:</strong> HP {memoryDetails.stats.hp} / ATK{' '}
                      {memoryDetails.stats.attack} / DEF {memoryDetails.stats.defense}
                    </div>
                  )}
                  {memoryCardUrls[card.name] && (
                    <div class="memory-card-link-container">
                      <a href={memoryCardUrls[card.name]} class="memory-card-link">
                        View Details →
                      </a>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        })
      }
    </div>
  </section>

  <!-- Alternative Memory Cards Section -->
  <section class="build-section">
    <h2>Alternative Memory Cards</h2>
    <p style="color: var(--zn-text-secondary); margin-bottom: 1.5rem;">
      Good alternative options if you don't have the recommended cards:
    </p>

    <div class="memory-cards-grid">
      {
        finalBuild.alternativeMemoryCards.map(card => {
          // Create memory details object for enhanced layout
          type AlternativeMemoryCardData = {
            name: string;
            image: string;
            description?: string;
            stats: {
              hp: string;
              attack: string;
              defense: string;
            };
          };

          let memoryDetails: AlternativeMemoryCardData | null = null;
          if (card.memoryImage && card.memoryStats) {
            memoryDetails = {
              name: card.name,
              image: card.memoryImage,
              stats: card.memoryStats,
              description: card.description,
            } as AlternativeMemoryCardData;
          }

          return (
            <div class={`memory-card-item ${card.characterSpecific ? 'character-specific' : ''}`}>
              <div class="memory-card-horizontal">
                {memoryDetails && (
                  <div class="memory-card-image-container">
                    <ZNMemoryImage
                      imageName={memoryDetails.image}
                      alt={`${card.name} memory card`}
                      width={60}
                      height={60}
                      loading="eager"
                    />
                  </div>
                )}
                <div class="memory-card-content">
                  <div class="memory-card-header">
                    <div class="memory-card-name">{card.name}</div>
                  </div>
                  <div class="memory-card-effect">{card.description || card.effect}</div>

                  {/* Spending recommendation note */}
                  {card.spendingNote && (
                    <div class="memory-card-spending-note">
                      <span class="note-title">Note:</span>
                      <span class="note-content">{card.spendingNote}</span>
                    </div>
                  )}

                  {/* General note */}
                  {card.note && (
                    <div class="memory-card-spending-note">
                      <span class="note-title">Note:</span>
                      <span class="note-content">{card.note}</span>
                    </div>
                  )}

                  {memoryDetails && (
                    <div class="memory-card-stats">
                      <strong>Stats:</strong> HP {memoryDetails.stats.hp} / ATK{' '}
                      {memoryDetails.stats.attack} / DEF {memoryDetails.stats.defense}
                    </div>
                  )}
                  {/* Only show "View Details" for memory cards with dedicated pages */}
                  {memoryCardUrls[card.name] && (
                    <div class="memory-card-link-container">
                      <a href={memoryCardUrls[card.name]} class="memory-card-link">
                        View Details →
                      </a>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        })
      }
    </div>
  </section>

  <!-- Runes Section -->
  <section class="build-section">
    <h2>Runes Priorities</h2>
    <p style="color: var(--zn-text-secondary); margin-bottom: 1.5rem;">
      Focus on these rune stats for {finalCharacter.name}:
    </p>

    <div
      style="background-color: var(--zn-bg-secondary); border: 1px solid var(--zn-border); border-radius: 4px; padding: 1.5rem; margin-bottom: 1rem;"
    >
      <div
        style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;"
      >
        <div>
          <div style="color: var(--zn-text-secondary); font-size: 0.9rem; margin-bottom: 0.5rem;">
            Primary Stat:
          </div>
          <div style="color: var(--zn-text-primary); font-weight: 600; font-size: 1.1rem;">
            {finalBuild.runes.primary}
          </div>
        </div>
        <div>
          <div style="color: var(--zn-text-secondary); font-size: 0.9rem; margin-bottom: 0.5rem;">
            Secondary Stat:
          </div>
          <div style="color: var(--zn-text-primary); font-weight: 600; font-size: 1.1rem;">
            {finalBuild.runes.secondary}
          </div>
        </div>
      </div>
    </div>

    <h3>Highly Recommended Stats:</h3>
    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem;">
      {
        finalBuild.runes.stats.slice(0, 4).map(stat => (
          <span
            style="background-color: var(--zn-primary);
                    color: #000000;
                    font-weight: 600;
                    padding: 0.5rem 1rem;
                    border-radius: 4px;
                    border: 1px solid var(--zn-primary);"
          >
            {stat}
          </span>
        ))
      }
    </div>

    {
      finalBuild.runes.additionalStats && finalBuild.runes.additionalStats.length > 0 && (
        <>
          <h3>Additional Stats:</h3>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            {finalBuild.runes.additionalStats.map(stat => (
              <span
                style="background-color: var(--zn-bg-tertiary);
                      color: var(--zn-text-primary);
                      padding: 0.5rem 1rem;
                      border-radius: 4px;
                      border: 1px solid var(--zn-border-light);"
              >
                {stat}
              </span>
            ))}
          </div>
        </>
      )
    }

    {
      finalBuild.runes.buildNote && (
        <div style="background-color: var(--zn-bg-tertiary); border: 1px solid var(--zn-border-light); border-radius: 4px; padding: 1rem; margin: 2rem 0;">
          <div style="color: var(--zn-text-secondary); font-size: 0.9rem; font-style: italic;">
            <strong style="color: var(--zn-primary);">Build Note:</strong>{' '}
            {finalBuild.runes.buildNote}
          </div>
        </div>
      )
    }

    <h3>Recommended Rune Sets:</h3>
    <div
      style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;"
    >
      {
        finalBuild.runes.recommendedSets.map((runeSet: any) => (
          <ZNRuneSetDisplay runeSet={runeSet} />
        ))
      }
    </div>

    {
      finalBuild.runes.alternativeSets && finalBuild.runes.alternativeSets.length > 0 && (
        <>
          <h3>Alternative Builds:</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">
            {finalBuild.runes.alternativeSets.map((runeSet: any) => (
              <ZNRuneSetDisplay runeSet={runeSet} />
            ))}
          </div>
        </>
      )
    }
  </section>

  <!-- Main Stats by Position Section -->
  <section class="build-section">
    <h2>Main Stats by Position</h2>
    <p style="color: var(--zn-text-secondary); margin-bottom: 1.5rem;">
      Recommended main stats for each rune position for {finalCharacter.name}:
    </p>

    <div class="main-stats-grid">
      {
        Object.entries(finalBuild.mainStatsByPosition).map(([position, data]: [string, any]) => (
          <div class="main-stat-card">
            <h3>{data.name}</h3>

            {data.isFixed ? (
              <div class="main-stat-fixed">
                <div class="main-stat-fixed-value">{data.stat}</div>
              </div>
            ) : (
              <div class="main-stat-variable">
                <div class="main-stat-recommended">Recommended: {data.recommendedStat}</div>
                <div class="main-stat-options-label">
                  <strong>Available Options:</strong>
                </div>
                <div class="main-stat-options-list">
                  {data.availableStats.map(stat => {
                    // Check if current stat is one of the recommended options
                    const recommendedOptions = data.recommendedStat
                      .split(' / ')
                      .map(opt => opt.trim());
                    const isRecommended = recommendedOptions.some(rec => stat.includes(rec));

                    return (
                      <span class={`main-stat-option ${isRecommended ? 'recommended' : ''}`}>
                        {stat}
                      </span>
                    );
                  })}
                </div>
              </div>
            )}

            <p class="main-stat-description">{data.description}</p>
          </div>
        ))
      }
    </div>
  </section>

  <!-- Team Synergy Section -->
  <section class="build-section">
    <h2>Team Synergy</h2>
    <h3>Good Teammates:</h3>
    <div class="synergy-character-list">
      {finalBuild.teamSynergy.goodWith.map(ally => <span class="synergy-character">{ally}</span>)}
    </div>
    {
      finalBuild.teamSynergy.note && (
        <p style="color: var(--zn-text-secondary); font-style: italic; margin-top: 1rem;">
          {finalBuild.teamSynergy.note}
        </p>
      )
    }
  </section>
</CharacterBuildIndividualLayout>
