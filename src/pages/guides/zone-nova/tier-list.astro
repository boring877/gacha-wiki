---
import TierListLayout from '../../../layouts/zone-nova/TierListLayout.astro';
import Breadcrumb from '../../../components/zone-nova/Breadcrumb.astro';
import { ZONE_NOVA_CHARACTERS } from '../../../data/zone-nova/characters.js';
import { ALL_TIER_LISTS, TIER_DEFINITIONS } from '../../../data/zone-nova/tier-lists.js';

// Create a map of character data for quick lookup
const characterMap = {};
ZONE_NOVA_CHARACTERS.forEach(char => {
  characterMap[char.name] = char;
});

// Helper function to get tier class name
function getTierClassName(tier: string): string {
  return tier.toLowerCase().replace('+', '-plus').replace(/\s+/g, '-');
}
---

<TierListLayout
  title="Zone Nova Tier List - Character Rankings & Meta Guide"
  description="Comprehensive Zone Nova tier lists for PvE, PvP, Rifts, and Guild Raids. Find the best characters and team compositions for every game mode."
>
  <!-- Breadcrumb Navigation -->
  <Breadcrumb
    items={[
      { name: 'Home', href: '/' },
      { name: 'Zone Nova', href: '/guides/zone-nova/' },
      { name: 'Tier List' },
    ]}
  />

  <div class="tier-list-container">
    <!-- Mode Toggle -->
    <div class="mode-toggle">
      <button class="mode-btn active" id="view-mode-btn"> View Tier Lists </button>
      <button class="mode-btn" id="maker-mode-btn"> Create Your Own </button>
    </div>

    <!-- View Mode Content -->
    <div id="view-mode-content">
      <!-- Tier List Type Selector -->
      <div class="tier-list-selector">
        <button class="tier-type-btn active" data-list-type="pve"> Overall PvE </button>
        <button class="tier-type-btn" data-list-type="pvp"> PvP Arena </button>
        <button class="tier-type-btn" data-list-type="rift"> Space-Time Rifts </button>
        <button class="tier-type-btn" data-list-type="guild-raid"> Guild Raid </button>
        <button class="tier-type-btn" data-list-type="new-player"> New Player / F2P </button>
      </div>
    </div>

    <!-- Maker Mode Content -->
    <div id="maker-mode-content" style="display: none;">
      <div class="maker-controls">
        <button class="control-btn" id="reset-tier-list">Reset</button>
      </div>
    </div>

    <!-- Tier List Info -->
    <div class="tier-list-info" id="tier-list-info">
      <h2 class="tier-list-title" id="list-title">Overall PvE Tier List</h2>
      <p class="tier-list-description" id="list-description">
        Character rankings for general PvE content including story, events, and exploration.
      </p>
      <p class="tier-list-updated" id="list-updated">Last updated: 2025-09-19</p>
    </div>

    <!-- Maker Mode Layout -->
    <div class="maker-layout" id="maker-layout" style="display: none;">
      <!-- Desktop: Side Pool -->
      <div class="side-pool" id="side-pool">
        <h3>Character Pool</h3>
        <div class="pool-characters" id="character-pool">
          {/* Characters will be populated here */}
        </div>
      </div>

      <!-- Tier List -->
      <div class="maker-tier-list">
        <div class="tier-list-display" id="maker-tier-display">
          {
            Object.entries(TIER_DEFINITIONS).map(([tier, definition]) => (
              <div class="tier-row">
                <div class={`tier-label tier-${getTierClassName(tier)}`}>{definition.label}</div>
                <div class="tier-characters droppable" data-tier={tier}>
                  {/* Characters will be populated by JavaScript */}
                </div>
              </div>
            ))
          }
        </div>
      </div>
    </div>

    <!-- Regular Tier List Display -->
    <div class="tier-list-display" id="tier-list-display">
      {
        Object.entries(TIER_DEFINITIONS).map(([tier, definition]) => (
          <div class="tier-row">
            <div class={`tier-label tier-${getTierClassName(tier)}`}>{definition.label}</div>
            <div class="tier-characters" data-tier={tier}>
              {/* Characters will be populated by JavaScript */}
            </div>
          </div>
        ))
      }
    </div>

    <!-- Tier Legend -->
    <div class="tier-legend" id="tier-legend">
      {
        Object.entries(TIER_DEFINITIONS).map(([tier, definition]) => (
          <div class="legend-item">
            <div class={`legend-tier tier-${getTierClassName(tier)}`}>{definition.label}</div>
            <div class="legend-description">
              <span class="legend-label">{definition.label} Tier</span>
              <span class="legend-text">{definition.description}</span>
            </div>
          </div>
        ))
      }
    </div>

    <!-- Quick Links -->
    <div
      style="display: flex; gap: 1rem; justify-content: center; margin: 2rem 0; flex-wrap: wrap;"
    >
      <a
        href="/guides/zone-nova/characters/"
        style="display: inline-block; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, var(--amber-glow), #FF9800); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s ease;"
      >
        Character Database
      </a>
      <a
        href="/guides/zone-nova/team-synergy"
        style="display: inline-block; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #64b5f6, #42a5f5); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s ease;"
      >
        Team Synergy
      </a>
      <a
        href="/guides/zone-nova/character-rankings"
        style="display: inline-block; padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #66bb6a, #4caf50); color: white; text-decoration: none; border-radius: 10px; font-weight: 600; transition: all 0.3s ease;"
      >
        Stat Rankings
      </a>
    </div>
  </div>

  <script define:vars={{ ALL_TIER_LISTS, characterMap, TIER_DEFINITIONS }}>
    document.addEventListener('DOMContentLoaded', () => {
      // Cache DOM elements
      const listTitle = document.getElementById('list-title');
      const listDescription = document.getElementById('list-description');
      const listUpdated = document.getElementById('list-updated');
      const tierDisplay = document.getElementById('tier-list-display');
      const typeButtons = document.querySelectorAll('.tier-type-btn');
      const viewModeBtn = document.getElementById('view-mode-btn');
      const makerModeBtn = document.getElementById('maker-mode-btn');
      const viewModeContent = document.getElementById('view-mode-content');
      const makerModeContent = document.getElementById('maker-mode-content');
      const tierListInfo = document.getElementById('tier-list-info');
      const tierLegend = document.getElementById('tier-legend');
      const characterPool = document.getElementById('character-pool');
      const makerLayout = document.getElementById('maker-layout');
      const resetBtn = document.getElementById('reset-tier-list');

      // Current active tier list
      let currentListType = 'pve';
      let currentMode = 'view';
      let selectedCharacter = null; // For mobile tap selection

      // Function to populate tier list
      function populateTierList(listType) {
        const tierList = ALL_TIER_LISTS[listType];
        if (!tierList) return;

        // Update info
        if (listTitle) listTitle.textContent = tierList.name;
        if (listDescription) listDescription.textContent = tierList.description;
        if (listUpdated) listUpdated.textContent = `Last updated: ${tierList.lastUpdated}`;

        // Clear and populate each tier
        Object.keys(TIER_DEFINITIONS).forEach(tier => {
          // In view mode, target the regular tier display, not maker mode
          const tierContainer = document.querySelector(`#tier-list-display [data-tier="${tier}"]`);
          if (!tierContainer) return;

          // Clear existing characters
          tierContainer.innerHTML = '';

          // Get characters for this tier
          const characters = tierList.tiers[tier] || [];

          if (characters.length === 0) {
            tierContainer.innerHTML = '<div class="empty-tier">No characters in this tier</div>';
            return;
          }

          // Add each character
          characters.forEach(charInfo => {
            const charData = characterMap[charInfo.name];
            if (!charData) return;

            // Create character card (data is from static files, safe to use template)
            const card = document.createElement('div');
            card.className = 'tier-character-card';
            const elementClass = charData.element ? charData.element.toLowerCase() : '';
            const elementName = charData.element
              ? charData.element.charAt(0).toUpperCase() + charData.element.slice(1).toLowerCase()
              : '';

            // Use template for faster creation (data is from static files, already sanitized)
            card.innerHTML = `
              <div class="character-image-wrapper">
                <img src="${charData.image.replace(/"/g, '&quot;')}" alt="${charData.name.replace(/"/g, '&quot;')}" loading="lazy">
              </div>
              <div class="character-name">${charData.name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
              <div class="character-badges">
                <span class="mini-badge rarity-${charData.rarity.toLowerCase()}">${charData.rarity.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
                ${charData.element ? `<span class="mini-badge element-${elementClass}">${elementName.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>` : ''}
              </div>
            `;

            // Add click event to navigate to character page
            card.addEventListener('click', () => {
              window.location.href = charData.detailUrl;
            });

            tierContainer.appendChild(card);
          });
        });

        // No animations - removed per user request
      }

      // Add event listeners to type buttons
      typeButtons.forEach(button => {
        button.addEventListener('click', () => {
          const listType = button.dataset.listType;
          if (!listType || listType === currentListType) return;

          // Update active button
          typeButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');

          // Update current list type
          currentListType = listType;

          // Populate new tier list
          populateTierList(listType);
        });
      });

      // Mode switching
      viewModeBtn.addEventListener('click', () => {
        currentMode = 'view';
        viewModeBtn.classList.add('active');
        makerModeBtn.classList.remove('active');
        viewModeContent.style.display = 'block';
        makerModeContent.style.display = 'none';
        tierListInfo.style.display = 'block';
        tierDisplay.style.display = 'block';
        if (tierLegend) tierLegend.style.display = 'grid';
        if (makerLayout) makerLayout.style.display = 'none';
        populateTierList(currentListType);
      });

      makerModeBtn.addEventListener('click', () => {
        currentMode = 'maker';
        makerModeBtn.classList.add('active');
        viewModeBtn.classList.remove('active');
        viewModeContent.style.display = 'none';
        makerModeContent.style.display = 'block';
        tierListInfo.style.display = 'none';
        tierDisplay.style.display = 'none';
        if (tierLegend) tierLegend.style.display = 'none';
        if (makerLayout) makerLayout.style.display = 'flex';

        initializeMakerMode();
      });

      // Initialize maker mode
      function initializeMakerMode() {
        // Update title
        if (listTitle) {
          listTitle.textContent = 'Create Your Own Tier List';
        }
        if (listDescription) {
          const isMobile = window.innerWidth <= 768;
          listDescription.textContent = isMobile
            ? 'Tap a character, then tap a tier to place it'
            : 'Drag characters from the pool to create your custom tier list';
        }
        if (listUpdated) {
          listUpdated.textContent = '';
        }

        // Clear and setup tier rows for maker mode
        const makerTierDisplay = document.querySelector('#maker-tier-display');
        if (makerTierDisplay) {
          makerTierDisplay.querySelectorAll('.tier-characters').forEach(tierContainer => {
            tierContainer.innerHTML = '<div class="drop-zone-hint">Drop characters here</div>';
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
              setupMobileTierZone(tierContainer);
            } else {
              setupDropZone(tierContainer);
            }
          });
        }

        // Populate character pool
        populateCharacterPool();

        // Setup pool as drop zone (desktop only)
        if (window.innerWidth > 768) {
          setupPoolDropZone();
        }
      }

      // Populate character pool with all characters
      function populateCharacterPool() {
        if (!characterPool) return;
        characterPool.innerHTML = '';

        // Get all unique characters
        const allCharacters = Object.values(characterMap);

        allCharacters.forEach(charData => {
          const card = createPoolCard(charData);
          characterPool.appendChild(card);
        });
      }

      // Setup pool tab filtering
      function setupPoolTabs() {
        const tabs = document.querySelectorAll('.pool-tab');
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            // Update active tab
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Filter characters
            const rarity = tab.dataset.rarity;
            populateCharacterPool(rarity);
          });
        });
      }

      // Create small pool card
      function createPoolCard(charData) {
        const card = document.createElement('div');
        card.className = 'pool-character-card draggable';
        card.draggable = true;
        card.dataset.character = charData.name;

        const elementClass = charData.element ? charData.element.toLowerCase() : '';
        const elementName = charData.element
          ? charData.element.charAt(0).toUpperCase() + charData.element.slice(1).toLowerCase()
          : '';

        // Use template for pool card (data is from static files, safe with escaping)
        card.innerHTML = `
          <img src="${charData.image.replace(/"/g, '&quot;')}" alt="${charData.name.replace(/"/g, '&quot;')}" loading="lazy">
          <div class="pool-character-name">${charData.name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
          <div class="pool-character-badges">
            <span class="pool-mini-badge rarity-${charData.rarity.toLowerCase()}">${charData.rarity.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
            ${charData.element ? `<span class="pool-mini-badge element-${elementClass}">${elementName.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>` : ''}
          </div>
        `;

        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
          // Mobile: Tap to select
          card.addEventListener('click', () => {
            // Clear previous selection
            document.querySelectorAll('.pool-character-card').forEach(c => {
              c.classList.remove('selected');
            });

            // Select this card
            card.classList.add('selected');
            selectedCharacter = charData;

            // Highlight tier zones
            document.querySelectorAll('.tier-characters').forEach(zone => {
              zone.classList.add('awaiting-placement');
            });
          });
        } else {
          // Desktop: Drag and drop
          card.addEventListener('dragstart', e => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('character', charData.name);
            e.dataTransfer.setData('source', 'pool');
            card.classList.add('dragging');
          });

          card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
          });
        }

        return card;
      }

      // Setup mobile tier zone (tap to place)
      function setupMobileTierZone(zone) {
        zone.addEventListener('click', () => {
          if (selectedCharacter) {
            // Remove hint if present
            const hint = zone.querySelector('.drop-zone-hint');
            if (hint) hint.remove();

            // Check if character already exists and remove it
            const existingCard = document.querySelector(
              `[data-character="${selectedCharacter.name}"]`
            );
            if (existingCard) {
              existingCard.remove();
            }

            // Add character to tier
            const card = createDraggableCard(selectedCharacter);
            zone.appendChild(card);

            // Clear selection
            document.querySelectorAll('.pool-character-card').forEach(c => {
              c.classList.remove('selected');
            });
            document.querySelectorAll('.tier-characters').forEach(z => {
              z.classList.remove('awaiting-placement');
            });
            selectedCharacter = null;
          }
        });
      }

      // Create draggable character card
      function createDraggableCard(charData) {
        const card = document.createElement('div');
        card.className = 'tier-character-card draggable';
        card.draggable = true;
        card.dataset.character = charData.name;

        const elementClass = charData.element ? charData.element.toLowerCase() : '';
        const elementName = charData.element
          ? charData.element.charAt(0).toUpperCase() + charData.element.slice(1).toLowerCase()
          : '';

        // Use template for draggable card (data is from static files, safe with escaping)
        card.innerHTML = `
          <div class="character-image-wrapper">
            <img src="${charData.image.replace(/"/g, '&quot;')}" alt="${charData.name.replace(/"/g, '&quot;')}" loading="lazy">
          </div>
          <div class="character-name">${charData.name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
          <div class="character-badges">
            <span class="mini-badge rarity-${charData.rarity.toLowerCase()}">${charData.rarity.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
            ${charData.element ? `<span class="mini-badge element-${elementClass}">${elementName.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>` : ''}
          </div>
          <button class="remove-btn" title="Remove from tier">Ã—</button>
        `;

        // Remove button handler
        const removeBtn = card.querySelector('.remove-btn');
        removeBtn.addEventListener('click', e => {
          e.stopPropagation();
          // Move back to pool as SMALL card
          const charData = characterMap[card.dataset.character];
          if (charData) {
            const poolCard = createPoolCard(charData);
            characterPool.appendChild(poolCard);
          }
          card.remove();
        });

        // Drag events
        card.addEventListener('dragstart', e => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('character', charData.name);
          e.dataTransfer.setData('source', card.parentElement.id || 'pool');
          card.classList.add('dragging');
        });

        card.addEventListener('dragend', () => {
          card.classList.remove('dragging');
        });

        return card;
      }

      // Setup drop zone
      function setupDropZone(zone) {
        zone.addEventListener('dragover', e => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          zone.classList.add('drag-over');
        });

        zone.addEventListener('dragleave', () => {
          zone.classList.remove('drag-over');
        });

        zone.addEventListener('drop', e => {
          e.preventDefault();
          zone.classList.remove('drag-over');

          const characterName = e.dataTransfer.getData('character');
          const sourceId = e.dataTransfer.getData('source');
          const charData = characterMap[characterName];

          if (charData) {
            // Check if character already exists anywhere and remove it
            const existingCard = document.querySelector(`[data-character="${characterName}"]`);
            if (existingCard) {
              existingCard.remove();
            }

            // Remove hint if present
            const hint = zone.querySelector('.drop-zone-hint');
            if (hint) hint.remove();

            // Add character to tier
            const card = createDraggableCard(charData);
            zone.appendChild(card);
          }
        });
      }

      // Setup pool drop zone
      function setupPoolDropZone() {
        if (!characterPool) return;

        characterPool.addEventListener('dragover', e => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          characterPool.classList.add('drag-over');
        });

        characterPool.addEventListener('dragleave', () => {
          characterPool.classList.remove('drag-over');
        });

        characterPool.addEventListener('drop', e => {
          e.preventDefault();
          characterPool.classList.remove('drag-over');

          const characterName = e.dataTransfer.getData('character');
          const charData = characterMap[characterName];

          if (charData) {
            // Check if character already exists and remove it
            const existingCard = document.querySelector(`[data-character="${characterName}"]`);
            if (existingCard) {
              existingCard.remove();
            }

            // Add SMALL card back to pool
            const card = createPoolCard(charData);
            characterPool.appendChild(card);
          }
        });
      }

      // Reset tier list
      resetBtn?.addEventListener('click', () => {
        if (confirm('Reset tier list? This will move all characters back to the pool.')) {
          initializeMakerMode();
        }
      });

      // Initial population
      populateTierList('pve');
    });
  </script>
</TierListLayout>
