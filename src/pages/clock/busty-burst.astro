---
import BustyBurstClockLayout from '../../layouts/clock/BustyBurst.astro';
import { bustyBurstConfig } from '../../data/clock/busty-burst.js';
import { getActiveChallenges } from '../../data/busty-burst/limited-time-challenges.js';
import GameIcon from '../../assets/images/games/Busty_Burst/BG/Icon.png';

// Page metadata
const title = 'Busty Burst Clock - Server Reset Timer & Launch Countdown | GachaWiki';
const description =
  'Busty Burst Fantasy server reset timer and launch countdown - Track Busty Burst server resets and launch with real-time countdown timers. Never miss daily resets, weekly events with our precise UTC server time clock. Server resets at 03:00 UTC daily.';

// Get active LTC challenge
const activeChallenges = getActiveChallenges();
const activeChallenge = activeChallenges.length > 0 ? activeChallenges[0] : null;

// Create a new config object with the imported image and LTC data
const games = [
  {
    ...bustyBurstConfig,
    image: GameIcon,
    ltc: activeChallenge,
  },
];
---

<BustyBurstClockLayout title={title} description={description} games={games}>
  <!-- Structured data for better SEO -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Busty Burst Fantasy Server Reset Clock",
      "description": "Real-time server reset timer for Busty Burst Fantasy gacha game. Daily reset at 03:00 UTC. Track Busty Burst dailies and events.",
      "url": "https://gachawiki.info/clock/busty-burst",
      "mainEntity": {
        "@type": "WebApplication",
        "name": "Busty Burst Reset Clock & Timer",
        "description": "Track Busty Burst Fantasy server reset times. Daily server reset at 03:00 UTC. Never miss Busty Burst daily quests, energy refills, and farming cycles.",
        "applicationCategory": "GameApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        }
      },
      "publisher": {
        "@type": "Organization",
        "name": "GachaWiki",
        "url": "https://gachawiki.info"
      }
    }
  </script>
</BustyBurstClockLayout>

<!-- Simple inline clock script -->
<script define:vars={{ config: bustyBurstConfig }}>
  // Simple clock implementation
  let clockInterval;

  // Initialize clock when page loads
  function initClock() {
    updateClock();
    updateCurrentTime();
    updateWeeklyReset();
    updateMonthlyReset();
    updateLaunchInfo();
    updateHolidays();
    updatePiBustyDay();
    updateAnniversary();
    updateMaintenance();
    updateLTC();

    // Update every second
    clockInterval = setInterval(() => {
      updateClock();
      updateCurrentTime();
      updateWeeklyReset();
      updateMonthlyReset();
      updateLaunchInfo();
      updateHolidays();
      updatePiBustyDay();
      updateAnniversary();
      updateMaintenance();
      updateLTC();
    }, 1000);
  }

  // Update main clock (daily reset countdown)
  function updateClock() {
    const now = new Date();

    // Calculate time until next daily reset (03:00 UTC)
    const resetTime = new Date();
    resetTime.setUTCHours(3, 0, 0, 0);

    // If reset time has passed today, set for tomorrow
    if (resetTime <= now) {
      resetTime.setUTCDate(resetTime.getUTCDate() + 1);
    }

    const timeDiff = resetTime.getTime() - now.getTime();

    if (timeDiff > 0) {
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

      // Update main clock display
      const hoursEl = document.getElementById('clockHours');
      const minutesEl = document.getElementById('clockMinutes');
      const secondsEl = document.getElementById('clockSeconds');

      if (hoursEl) hoursEl.textContent = hours.toString().padStart(2, '0');
      if (minutesEl) minutesEl.textContent = minutes.toString().padStart(2, '0');
      if (secondsEl) secondsEl.textContent = seconds.toString().padStart(2, '0');
    }
  }

  // Update current time display
  function updateCurrentTime() {
    const now = new Date();

    // Update current date (UTC)
    const currentDateEl = document.getElementById('currentDate');
    if (currentDateEl) {
      const dateOptions = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
      currentDateEl.textContent = now.toLocaleDateString('en-US', {
        ...dateOptions,
        timeZone: 'UTC',
      });
    }

    // Update current UTC time
    const currentUTCEl = document.getElementById('currentUTC');
    if (currentUTCEl) {
      const utcTime = now.toLocaleTimeString('en-US', {
        hour12: false,
        timeZone: 'UTC',
      });
      currentUTCEl.textContent = `UTC ${utcTime}`;
    }
  }

  // Update weekly reset timer (Mondays at 03:00 UTC)
  function updateWeeklyReset() {
    const weeklyEl = document.getElementById('weeklyTime');
    if (!weeklyEl) return;

    const now = new Date();
    const resetTime = new Date();

    // Set to next Monday at 03:00 UTC
    resetTime.setUTCHours(3, 0, 0, 0);
    const daysUntilMonday = (1 + 7 - now.getUTCDay()) % 7 || 7; // Monday = 1
    resetTime.setUTCDate(now.getUTCDate() + daysUntilMonday);

    const timeDiff = resetTime.getTime() - now.getTime();
    if (timeDiff > 0) {
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

      let timeString = '';
      if (days > 0) timeString += `${days}d `;
      timeString += `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      weeklyEl.textContent = timeString;
    } else {
      weeklyEl.textContent = '00:00:00';
    }
  }

  // Update monthly reset timer (1st of each month at 03:00 UTC)
  function updateMonthlyReset() {
    const monthlyEl = document.getElementById('monthlyTime');
    if (!monthlyEl) return;

    const now = new Date();
    const resetTime = new Date();

    // Set to 1st of next month at 03:00 UTC
    resetTime.setUTCHours(3, 0, 0, 0);
    resetTime.setUTCDate(1);
    resetTime.setUTCMonth(now.getUTCMonth() + 1);

    const timeDiff = resetTime.getTime() - now.getTime();
    if (timeDiff > 0) {
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

      let timeString = '';
      if (days > 0) timeString += `${days}d `;
      timeString += `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      monthlyEl.textContent = timeString;
    } else {
      monthlyEl.textContent = '00:00:00';
    }
  }

  // Update launch information (days since launch)
  function updateLaunchInfo() {
    const launchDate = new Date('2025-12-04T00:00:00Z'); // Dec 4, 2025 00:00 UTC
    const now = new Date();

    // Show days since launch
    const daysSinceLaunch = Math.floor(
      (now.getTime() - launchDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    const launchDaysSinceEl = document.getElementById('launchDaysSince');
    if (launchDaysSinceEl) {
      if (daysSinceLaunch >= 0) {
        launchDaysSinceEl.textContent = daysSinceLaunch.toString();
      } else {
        // If before launch, show countdown
        const daysUntilLaunch = Math.abs(daysSinceLaunch);
        launchDaysSinceEl.textContent = `-${daysUntilLaunch}`;
      }
    }

    // Update launch status
    const launchStatusDot = document.getElementById('launchStatusDot');
    const launchStatusText = document.getElementById('launchStatusText');

    if (launchStatusDot && launchStatusText) {
      if (daysSinceLaunch >= 0) {
        launchStatusDot.className = 'status-dot status-active';
        launchStatusText.textContent = 'Launched';
      } else {
        launchStatusDot.className = 'status-dot status-coming-soon';
        launchStatusText.textContent = 'Coming Soon';
      }
    }
  }

  // Update holiday timers (Halloween and New Year)
  function updateHolidays() {
    const now = new Date();
    const currentYear = now.getFullYear();

    // Halloween timer (October 31st)
    const halloweenEl = document.getElementById('halloweenTime');
    if (halloweenEl) {
      const halloween = new Date(`${currentYear}-10-31T23:59:59Z`);
      if (halloween < now) {
        halloween.setFullYear(currentYear + 1);
      }

      const timeDiff = halloween.getTime() - now.getTime();
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      halloweenEl.textContent = `${days} days`;
    }

    // New Year timer (January 1st)
    const newyearEl = document.getElementById('newyearTime');
    if (newyearEl) {
      const newYear = new Date(`${currentYear + 1}-01-01T00:00:00Z`);

      const timeDiff = newYear.getTime() - now.getTime();
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      newyearEl.textContent = `${days} days`;
    }
  }

  // Update PI Busty Day timer (8th, 18th, 28th of each month)
  function updatePiBustyDay() {
    const piBustyDayEl = document.getElementById('piBustyDayTime');
    const piBustyDayDateEl = document.getElementById('piBustyDayDate');
    if (!piBustyDayEl) return;

    const now = new Date();
    const currentDay = now.getUTCDate();
    const currentMonth = now.getUTCMonth();
    const currentYear = now.getUTCFullYear();

    const piBustyDays = [8, 18, 28];
    let nextPiDay;
    let nextMonth = currentMonth;
    let nextYear = currentYear;

    // Find the next PI Busty Day
    const upcomingThisMonth = piBustyDays.find(d => d > currentDay);
    if (upcomingThisMonth) {
      nextPiDay = upcomingThisMonth;
    } else {
      // Move to next month's 8th
      nextPiDay = 8;
      nextMonth = currentMonth + 1;
      if (nextMonth > 11) {
        nextMonth = 0;
        nextYear++;
      }
    }

    const nextPiBustyDate = new Date(Date.UTC(nextYear, nextMonth, nextPiDay, 0, 0, 0)); // 00:00 UTC
    const timeDiff = nextPiBustyDate.getTime() - now.getTime();
    const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

    piBustyDayEl.textContent = `${days}d ${hours}h`;

    // Update the subtitle to show which date is next
    if (piBustyDayDateEl) {
      const monthNames = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
      ];
      piBustyDayDateEl.textContent = `${monthNames[nextMonth]} ${nextPiDay}`;
    }
  }

  // Update Anniversary timers (Anniversary: Dec 4, Half Anniversary: Jun 4)
  function updateAnniversary() {
    const now = new Date();
    const currentYear = now.getUTCFullYear();

    // Anniversary timer (December 4th)
    const anniversaryEl = document.getElementById('anniversaryTime');
    if (anniversaryEl) {
      let anniversary = new Date(Date.UTC(currentYear, 11, 4, 3, 0, 0)); // Dec 4 at 03:00 UTC
      if (anniversary <= now) {
        anniversary = new Date(Date.UTC(currentYear + 1, 11, 4, 3, 0, 0));
      }

      const timeDiff = anniversary.getTime() - now.getTime();
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      anniversaryEl.textContent = `${days}d ${hours}h`;
    }

    // Half Anniversary timer (June 4th)
    const halfAnniversaryEl = document.getElementById('halfAnniversaryTime');
    if (halfAnniversaryEl) {
      let halfAnniversary = new Date(Date.UTC(currentYear, 5, 4, 3, 0, 0)); // Jun 4 at 03:00 UTC
      if (halfAnniversary <= now) {
        halfAnniversary = new Date(Date.UTC(currentYear + 1, 5, 4, 3, 0, 0));
      }

      const timeDiff = halfAnniversary.getTime() - now.getTime();
      const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      halfAnniversaryEl.textContent = `${days}d ${hours}h`;
    }
  }

  // Update maintenance timer
  function updateMaintenance() {
    const serverStatusDot = document.getElementById('serverStatusDot');
    const serverStatusText = document.getElementById('serverStatusText');
    const maintenanceStartItem = document.getElementById('maintenanceStartItem');
    const maintenanceEndItem = document.getElementById('maintenanceEndItem');
    const noMaintenanceMessage = document.getElementById('noMaintenanceMessage');
    const maintenanceStartTime = document.getElementById('maintenanceStartTime');
    const maintenanceEndTime = document.getElementById('maintenanceEndTime');

    if (!serverStatusDot || !serverStatusText) return;

    const now = new Date();
    const maintenanceStart = new Date(config.maintenance.start);
    const maintenanceEnd = new Date(config.maintenance.end);

    if (now < maintenanceStart) {
      // Before maintenance - show countdown to start
      serverStatusDot.className = 'status-dot status-online';
      serverStatusText.textContent = 'Online';

      if (maintenanceStartItem) maintenanceStartItem.style.display = 'block';
      if (maintenanceEndItem) maintenanceEndItem.style.display = 'none';
      if (noMaintenanceMessage) noMaintenanceMessage.style.display = 'none';

      const timeDiff = maintenanceStart.getTime() - now.getTime();
      const hours = Math.floor(timeDiff / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

      if (maintenanceStartTime) {
        maintenanceStartTime.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    } else if (now >= maintenanceStart && now < maintenanceEnd) {
      // During maintenance - show countdown to end
      serverStatusDot.className = 'status-dot status-maintenance';
      serverStatusText.textContent = 'Maintenance';

      if (maintenanceStartItem) maintenanceStartItem.style.display = 'none';
      if (maintenanceEndItem) maintenanceEndItem.style.display = 'block';
      if (noMaintenanceMessage) noMaintenanceMessage.style.display = 'none';

      const timeDiff = maintenanceEnd.getTime() - now.getTime();
      const hours = Math.floor(timeDiff / (1000 * 60 * 60));
      const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

      if (maintenanceEndTime) {
        maintenanceEndTime.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    } else {
      // After maintenance - show online
      serverStatusDot.className = 'status-dot status-online';
      serverStatusText.textContent = 'Online';

      if (maintenanceStartItem) maintenanceStartItem.style.display = 'none';
      if (maintenanceEndItem) maintenanceEndItem.style.display = 'none';
      if (noMaintenanceMessage) noMaintenanceMessage.style.display = 'block';
    }
  }

  // Update Limited Time Challenge timer
  function updateLTC() {
    const ltcCard = document.getElementById('ltcTimerCard');
    if (!ltcCard) return;

    const ltcTimeEl = document.getElementById('ltcTime');
    const ltcStatusDot = document.getElementById('ltcStatusDot');
    const ltcStatusText = document.getElementById('ltcStatusText');
    if (!ltcTimeEl) return;

    const endDateStr = ltcCard.dataset.end;
    if (!endDateStr) return;

    // Parse date format: '2026/01/20' -> Date object (03:00 UTC)
    const [year, month, day] = endDateStr.split('/').map(Number);
    const endDate = new Date(Date.UTC(year, month - 1, day, 3, 0, 0));

    const now = new Date();
    const timeDiff = endDate.getTime() - now.getTime();

    if (timeDiff <= 0) {
      ltcTimeEl.textContent = 'Ended';
      if (ltcStatusDot) ltcStatusDot.className = 'status-dot status-offline';
      if (ltcStatusText) ltcStatusText.textContent = 'Ended';
      return;
    }

    const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

    let timeString = '';
    if (days > 0) timeString += `${days}d `;
    timeString += `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    ltcTimeEl.textContent = timeString;
  }

  // Start clock when page is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initClock);
  } else {
    initClock();
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (clockInterval) {
      clearInterval(clockInterval);
    }
  });
</script>
