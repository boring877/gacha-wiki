---
// Import centralized Zone Nova data component
import { CHARACTER_DATA_MAP } from './ZNCharacterData.astro';
---

<!-- Setup data BEFORE loading the script -->
<script define:vars={{ characterDataMap: CHARACTER_DATA_MAP }}>
  // Set up global data for the external comparison script
  window.zoneNovaComparisonData = {
    characterDataMap: characterDataMap,
  };
</script>

<!-- Comparison script -->
<script type="module">
  /**
   * Zone Nova Character Comparison Tool
   * Secure, optimized character comparison functionality
   */

  class ZoneNovaCharacterComparison {
    constructor() {
      this.selectedCharacters = [];
      this.maxCharacters = 4;
      this.characterDataCache = new Map();
      this.eventListeners = new Map();
      this.characterCardListeners = new WeakMap();
      this.sortState = { column: null, asc: false };

      // Faction abbreviation mapping for display
      this.factionAbbreviations = {
        'Monochrome Nation': 'Mono Nation',
        'Pingjing City': 'Pingjing',
        'Bicta Tower': 'Bicta',
      };

      this.init();
    }

    async init() {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.initializeApp());
      } else {
        this.initializeApp();
      }
    }

    initializeApp() {
      // Get data from window global (set by Astro)
      if (window.zoneNovaComparisonData) {
        // Character cards are pre-rendered, no need to process data
      } else {
        // Zone Nova comparison data not found

        return;
      }

      // Small delay to ensure DOM elements are fully rendered
      setTimeout(() => {
        this.initializeCharacterSelection();
        this.initializeComparisonControls();
        this.initializeFilterControls();
      }, 100);
    }

    // Character data loader (Cloudflare compatible)
    loadCharacterData(slug) {
      // Input validation
      if (!slug || typeof slug !== 'string') {
        return null;
      }

      if (this.characterDataCache.has(slug)) {
        return this.characterDataCache.get(slug);
      }

      try {
        // Get data from global variable (passed from Astro)
        const data = window.zoneNovaComparisonData?.characterDataMap?.[slug];

        this.characterDataCache.set(slug, data || null);
        return data || null;
      } catch (_error) {
        this.characterDataCache.set(slug, null);
        return null;
      }
    }

    initializeCharacterSelection() {
      const characterCards = document.querySelectorAll('.character-select-card');

      if (characterCards.length === 0) {
        // Try again after a delay
        setTimeout(() => this.initializeCharacterSelection(), 500);
        return;
      }

      // Clean up existing listeners
      this.cleanupCharacterCardListeners();

      characterCards.forEach((card, _index) => {
        const cardClickHandler = event => {
          event.preventDefault();
          event.stopPropagation();

          const characterSlug = card.dataset.characterSlug;

          // Input validation
          if (!characterSlug || typeof characterSlug !== 'string') {
            return;
          }

          const isSelected = card.dataset.selected === 'true';

          if (isSelected) {
            // Remove from selection
            this.selectedCharacters = this.selectedCharacters.filter(
              slug => slug !== characterSlug
            );
            card.dataset.selected = 'false';
          } else {
            // Add to selection - if at max, replace the oldest selection
            if (this.selectedCharacters.length < this.maxCharacters) {
              this.selectedCharacters.push(characterSlug);
              card.dataset.selected = 'true';
            } else {
              // Replace oldest selection with new one
              const oldestSlug = this.selectedCharacters.shift(); // Remove first (oldest)
              this.selectedCharacters.push(characterSlug); // Add new one

              // Update UI - unselect the old one
              const oldCard = document.querySelector(`[data-character-slug="${oldestSlug}"]`);
              if (oldCard) {
                oldCard.dataset.selected = 'false';
              }

              // Select the new one
              card.dataset.selected = 'true';
            }
          }

          this.updateComparisonTable();

          // Auto-navigate to comparison when 4 characters selected
          if (this.selectedCharacters.length === this.maxCharacters) {
            this.navigateToComparison();
          }
        };

        card.addEventListener('click', cardClickHandler);
        this.characterCardListeners.set(card, cardClickHandler);
      });
    }

    initializeComparisonControls() {
      const clearBtn = document.getElementById('clear-comparison');

      if (clearBtn) {
        const clearHandler = () => {
          this.clearComparison();
        };
        clearBtn.addEventListener('click', clearHandler);
        this.eventListeners.set('clear-comparison', () => {
          clearBtn.removeEventListener('click', clearHandler);
        });
      } else {
        // Try to set up the button later when comparison table becomes visible
        this.setupClearButtonWhenVisible();
      }
    }

    // Try to attach clear button event listener with retry mechanism
    setupClearButtonWhenVisible() {
      const tryAttachListener = () => {
        const clearBtn = document.getElementById('clear-comparison');
        if (clearBtn && !this.eventListeners.has('clear-comparison')) {
          const clearHandler = () => {
            this.clearComparison();
          };
          clearBtn.addEventListener('click', clearHandler);
          this.eventListeners.set('clear-comparison', () => {
            clearBtn.removeEventListener('click', clearHandler);
          });

          return true;
        }
        return false;
      };

      // Try immediately
      if (tryAttachListener()) return;

      // Try with increasing delays
      const delays = [100, 500, 1000, 2000];
      delays.forEach(delay => {
        setTimeout(() => {
          if (!this.eventListeners.has('clear-comparison')) {
            tryAttachListener();
          }
        }, delay);
      });
    }

    initializeFilterControls() {
      // Clean up existing filter listeners
      this.cleanupFilterListeners();

      const rarityFilter = document.getElementById('rarity-filter');
      const roleFilter = document.getElementById('role-filter');
      const classFilter = document.getElementById('class-filter');
      const elementFilter = document.getElementById('element-filter');
      const factionFilter = document.getElementById('faction-filter');
      const sortBtns = document.querySelectorAll('.sort-btn');
      const clearFiltersBtn = document.getElementById('clear-filters');

      // Filter listeners
      const filterHandler = () => this.applyFilters();

      if (rarityFilter) {
        rarityFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('rarity-filter', () => {
          rarityFilter.removeEventListener('change', filterHandler);
        });
      }

      if (roleFilter) {
        roleFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('role-filter', () => {
          roleFilter.removeEventListener('change', filterHandler);
        });
      }

      if (classFilter) {
        classFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('class-filter', () => {
          classFilter.removeEventListener('change', filterHandler);
        });
      }

      if (elementFilter) {
        elementFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('element-filter', () => {
          elementFilter.removeEventListener('change', filterHandler);
        });
      }

      if (factionFilter) {
        factionFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('faction-filter', () => {
          factionFilter.removeEventListener('change', filterHandler);
        });
      }

      // Sort button listeners
      sortBtns.forEach(btn => {
        const sortHandler = () => {
          const col = btn.dataset.sort;
          // Input validation
          if (!col || typeof col !== 'string') {
            return;
          }

          // Toggle sort direction if same column, otherwise start with ascending
          this.sortState.asc = this.sortState.column === col ? !this.sortState.asc : true;
          this.sortState.column = col;

          // Update button states
          sortBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          this.applyFilters();
        };

        btn.addEventListener('click', sortHandler);
        this.eventListeners.set(`sort-${btn.dataset.sort}`, () => {
          btn.removeEventListener('click', sortHandler);
        });
      });

      if (clearFiltersBtn) {
        const clearFiltersHandler = () => this.clearFilters();
        clearFiltersBtn.addEventListener('click', clearFiltersHandler);
        this.eventListeners.set('clear-filters', () => {
          clearFiltersBtn.removeEventListener('click', clearFiltersHandler);
        });
      }
    }

    applyFilters() {
      const rarityFilter = document.getElementById('rarity-filter')?.value || '';
      const roleFilter = document.getElementById('role-filter')?.value || '';
      const classFilter = document.getElementById('class-filter')?.value || '';
      const elementFilter = document.getElementById('element-filter')?.value || '';
      const factionFilter = document.getElementById('faction-filter')?.value || '';

      // Filter by showing/hiding pre-rendered character cards
      document.querySelectorAll('.character-select-card').forEach(card => {
        const cardRarity = card.dataset.rarity || '';
        const cardRole = card.dataset.role || '';
        const cardClass = card.dataset.class || '';
        const cardElement = card.dataset.element || '';
        const cardFaction = card.dataset.faction || '';

        const matchesRarity = !rarityFilter || cardRarity === rarityFilter;
        const matchesRole = !roleFilter || cardRole === roleFilter;
        const matchesClass = !classFilter || cardClass === classFilter;
        const matchesElement = !elementFilter || cardElement === elementFilter;
        const matchesFaction = !factionFilter || cardFaction === factionFilter;

        const shouldShow =
          matchesRarity && matchesRole && matchesClass && matchesElement && matchesFaction;
        card.style.display = shouldShow ? 'flex' : 'none';
      });

      // Apply sorting to visible cards
      if (this.sortState.column) {
        this.sortVisibleCharacters(this.sortState.column, this.sortState.asc);
      }
    }

    sortVisibleCharacters(sortOption, ascending) {
      const characterGrid = document.querySelector('.character-grid');
      if (!characterGrid) return;

      // Get all visible character cards
      const visibleCards = Array.from(document.querySelectorAll('.character-select-card')).filter(
        card => card.style.display !== 'none'
      );

      // Sort based on data attributes
      visibleCards.sort((a, b) => {
        let aValue, bValue;

        switch (sortOption) {
          case 'hp':
            aValue = parseFloat(a.dataset.hp) || 0;
            bValue = parseFloat(b.dataset.hp) || 0;
            break;
          case 'attack':
            aValue = parseFloat(a.dataset.attack) || 0;
            bValue = parseFloat(b.dataset.attack) || 0;
            break;
          case 'defense':
            aValue = parseFloat(a.dataset.defense) || 0;
            bValue = parseFloat(b.dataset.defense) || 0;
            break;
          case 'critRate':
            aValue = parseFloat(a.dataset.critRate) || 0;
            bValue = parseFloat(b.dataset.critRate) || 0;
            break;
          default:
            return 0;
        }

        const comparison = bValue - aValue;
        return ascending ? comparison : -comparison;
      });

      // Reorder the cards in the DOM
      visibleCards.forEach(card => {
        characterGrid.appendChild(card);
      });
    }

    clearFilters() {
      const filters = [
        'rarity-filter',
        'role-filter',
        'class-filter',
        'element-filter',
        'faction-filter',
      ];

      // Clear all filter values with explicit reset
      filters.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.value = '';
          // Force change event to trigger filter update
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });

      // Clear active sort button and reset sort state
      document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
      this.sortState = { column: null, asc: false };

      // Show all character cards and reset to alphabetical order
      const characterGrid = document.querySelector('.character-grid');
      if (characterGrid) {
        const allCards = Array.from(document.querySelectorAll('.character-select-card'));

        // Sort by name using the character data
        allCards.sort((a, b) => {
          const nameA = a.querySelector('.character-name')?.textContent || '';
          const nameB = b.querySelector('.character-name')?.textContent || '';
          return nameA.localeCompare(nameB);
        });

        // Show all cards and reorder them
        allCards.forEach(card => {
          card.style.display = 'flex';
          characterGrid.appendChild(card);
        });
      }
    }

    async updateComparisonTable() {
      const comparisonTable = document.getElementById('comparison-table');
      if (!comparisonTable) {
        return;
      }

      if (this.selectedCharacters.length === 0) {
        comparisonTable.classList.remove('active');
        return;
      }

      comparisonTable.classList.add('active');

      // Ensure clear button is attached when table becomes active
      if (!this.eventListeners.has('clear-comparison')) {
        this.setupClearButtonWhenVisible();
      }

      // Clear existing data
      this.clearTableCells();

      // Populate table with selected characters
      const populationPromises = this.selectedCharacters.map(async (characterSlug, index) => {
        const characterCard = document.querySelector(`[data-character-slug="${characterSlug}"]`);
        if (characterCard) {
          // Extract character data from the card
          const characterData = {
            name: characterCard.querySelector('.character-name')?.textContent || '',
            image: characterCard.querySelector('.character-portrait')?.src || '',
            rarity: characterCard.dataset.rarity || '',
            element: characterCard.dataset.element || '',
            class: characterCard.dataset.class || '',
            role: characterCard.dataset.role || '',
            faction: characterCard.dataset.faction || '',
            stats: {
              hp: parseFloat(characterCard.dataset.hp) || 0,
              attack: parseFloat(characterCard.dataset.attack) || 0,
              defense: parseFloat(characterCard.dataset.defense) || 0,
              energyRecovery: parseFloat(characterCard.dataset.energyRecovery) || 0,
              critRate: parseFloat(characterCard.dataset.critRate) || 0,
              critDmg: parseFloat(characterCard.dataset.critDmg) || 0,
            },
          };
          await this.populateCharacterColumn(characterData, index + 1);
        }
      });

      await Promise.all(populationPromises);

      // Hide unused columns
      for (let i = this.selectedCharacters.length + 1; i <= this.maxCharacters; i++) {
        this.hideCharacterColumn(i);
      }

      // Generate mobile cards
      this.generateMobileCards();
    }

    // Generate mobile character cards
    generateMobileCards() {
      const mobileCardsContainer = document.getElementById('mobile-comparison-cards');
      if (!mobileCardsContainer) return;

      console.log('Generating mobile cards for', this.selectedCharacters.length, 'characters');
      mobileCardsContainer.innerHTML = '';

      this.selectedCharacters.forEach((characterSlug, index) => {
        const characterCard = document.querySelector(`[data-character-slug="${characterSlug}"]`);
        if (characterCard) {
          console.log('Creating mobile card for:', characterSlug);
          const mobileCard = this.createMobileCard(characterCard, index + 1);
          mobileCardsContainer.appendChild(mobileCard);
        } else {
          console.log('Character card not found for:', characterSlug);
        }
      });
    }

    // Create a mobile character card
    createMobileCard(characterCard, columnIndex) {
      const card = document.createElement('div');
      card.className = 'character-comparison-card';

      // Extract character data
      const characterData = {
        name: characterCard.querySelector('.character-name')?.textContent || '',
        image: characterCard.querySelector('.character-portrait')?.src || '',
        rarity: characterCard.dataset.rarity || '',
        element: characterCard.dataset.element || '',
        class: characterCard.dataset.class || '',
        role: characterCard.dataset.role || '',
        faction: characterCard.dataset.faction || '',
        stats: {
          hp: parseFloat(characterCard.dataset.hp) || 0,
          attack: parseFloat(characterCard.dataset.attack) || 0,
          defense: parseFloat(characterCard.dataset.defense) || 0,
          energyRecovery: parseFloat(characterCard.dataset.energyRecovery) || 0,
          critRate: parseFloat(characterCard.dataset.critRate) || 0,
          critDmg: parseFloat(characterCard.dataset.critDmg) || 0,
        },
      };

      // Get team skill data
      const characterSlug =
        characterCard.dataset.characterSlug || this.selectedCharacters[columnIndex - 1];
      const characterDataFull = this.loadCharacterData(characterSlug);
      const teamSkill = characterDataFull?.teamSkill;

      // Debug logging
      console.log('Mobile card debug:', {
        characterSlug,
        characterDataFull: characterDataFull ? 'found' : 'not found',
        teamSkill: teamSkill ? 'found' : 'not found',
      });

      card.innerHTML = `
        <div class="card-header">
          <img src="${characterData.image}" alt="${characterData.name}" class="card-portrait">
          <div class="card-info">
            <h3>${characterData.name}</h3>
            <div class="card-badges">
              <span class="rarity-badge ${characterData.rarity.toLowerCase()}">${characterData.rarity}</span>
              <span class="element-badge ${characterData.element.toLowerCase()}">${characterData.element}</span>
              <span class="role-badge ${characterData.role.toLowerCase()}">${characterData.role}</span>
            </div>
          </div>
        </div>

        <div class="card-section">
          <h4>Basic Information</h4>
          <div class="card-stats">
            <div class="card-stat">
              <span class="stat-label">Class</span>
              <span class="stat-value">${characterData.class}</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">Faction</span>
              <span class="stat-value">${this.factionAbbreviations[characterData.faction] || characterData.faction}</span>
            </div>
          </div>
        </div>

        <div class="card-section">
          <h4>Combat Stats</h4>
          <div class="card-stats">
            <div class="card-stat">
              <span class="stat-label">HP</span>
              <span class="stat-value">${characterData.stats.hp.toLocaleString()}</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">ATK</span>
              <span class="stat-value">${characterData.stats.attack.toLocaleString()}</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">DEF</span>
              <span class="stat-value">${characterData.stats.defense.toLocaleString()}</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">Energy</span>
              <span class="stat-value">${characterData.stats.energyRecovery}</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">CRIT Rate</span>
              <span class="stat-value">${characterData.stats.critRate}%</span>
            </div>
            <div class="card-stat">
              <span class="stat-label">CRIT DMG</span>
              <span class="stat-value">${characterData.stats.critDmg}%</span>
            </div>
          </div>
        </div>

        <div class="card-section">
          <h4>Combo Skill</h4>
          <div class="card-team-skill">
            ${
              teamSkill
                ? `
              <div class="team-skill-name">${teamSkill.name || 'Combo Skill'}</div>
              <div class="team-skill-description">${teamSkill.description}</div>
              <div class="team-skill-conditions">
                <strong>Requirements:</strong> ${teamSkill.requirements?.faction || characterData.faction} + ${teamSkill.requirements?.element || characterData.element}
              </div>
            `
                : `
              <div class="team-skill-unknown">No team skill data available</div>
            `
            }
          </div>
        </div>
      `;

      return card;
    }

    async populateCharacterColumn(character, columnIndex) {
      // Show character column
      const column = document.querySelector(
        `.premium-character-column[data-character="${columnIndex}"]`
      );
      if (column) {
        column.classList.add('active');
        column.style.display = 'block';
      } else {
        return;
      }

      // Populate character header
      const portrait = document.querySelector(`.premium-portrait[data-portrait="${columnIndex}"]`);
      if (portrait) {
        portrait.src = character.image;
        portrait.alt = character.name;
      }

      const nameEl = document.querySelector(`.character-name[data-name="${columnIndex}"]`);
      if (nameEl) {
        nameEl.textContent = character.name;
      }

      // Populate stats
      const stats = character.stats || {};

      const setStatValue = (statName, value) => {
        const el = document.querySelector(`[data-stat="${statName}-${columnIndex}"]`);
        if (el) {
          el.textContent = value;
          el.classList.add('active');
          el.style.display = 'flex';
          el.style.visibility = 'visible';
        }
      };

      const setBadgeValue = (statName, value, badgeType, abbreviations = null) => {
        const el = document.querySelector(`[data-stat="${statName}-${columnIndex}"]`);
        if (el) {
          // Handle long faction names
          let displayValue = value;
          if (badgeType === 'faction' && abbreviations) {
            displayValue = abbreviations[value] || value;
          }

          const span = document.createElement('span');
          span.className = `${badgeType}-badge ${value.toLowerCase().replace(/\s+/g, '-').replace(/\./g, '-')}`;
          span.textContent = displayValue;
          el.innerHTML = '';
          el.appendChild(span);
          el.classList.add('active');
          el.style.display = 'block';
          el.style.visibility = 'visible';
        }
      };

      setBadgeValue('rarity', character.rarity, 'rarity');
      setBadgeValue('class', character.class, 'class');
      setBadgeValue('role', character.role, 'role');
      setBadgeValue('faction', character.faction, 'faction', this.factionAbbreviations);
      setBadgeValue('element', character.element, 'element');

      // Get character slug from the original selected characters array
      const characterSlug = this.selectedCharacters[columnIndex - 1];
      const characterData = this.loadCharacterData(characterSlug);
      const detailedStats = characterData?.stats || stats;

      // Combat stats - prioritize detailed character data, fallback to basic stats
      const hp = detailedStats.hp || stats.hp;
      const attack = detailedStats.attack || stats.attack;
      const defense = detailedStats.defense || stats.defense;
      const energy =
        detailedStats.energyRegen || detailedStats.energyRecovery || stats.energyRecovery;
      const critRate = detailedStats.critRate || stats.critRate;
      const critDmg = detailedStats.critDamage || detailedStats.critDmg || stats.critDmg;

      // Get team skill data from character data
      const teamSkill = characterData?.teamSkill;

      setStatValue(
        'hp',
        hp !== undefined ? (typeof hp === 'string' ? hp : hp.toLocaleString()) : 'N/A'
      );
      setStatValue(
        'attack',
        attack !== undefined
          ? typeof attack === 'string'
            ? attack
            : attack.toLocaleString()
          : 'N/A'
      );
      setStatValue(
        'defense',
        defense !== undefined
          ? typeof defense === 'string'
            ? defense
            : defense.toLocaleString()
          : 'N/A'
      );
      setStatValue(
        'energy',
        energy !== undefined ? (typeof energy === 'string' ? energy : energy) : 'N/A'
      );
      setStatValue(
        'crit',
        critRate !== undefined ? (typeof critRate === 'string' ? critRate : critRate + '%') : '0%'
      );
      setStatValue(
        'critdmg',
        critDmg !== undefined ? (typeof critDmg === 'string' ? critDmg : critDmg + '%') : 'N/A'
      );

      // Team skill name - standardize to "Combo Skill" for consistency
      const teamSkillName = teamSkill ? 'Combo Skill' : 'No Team Skill';
      setStatValue('teamskillname', teamSkillName);

      // Team skill description
      const teamSkillValue = teamSkill?.description || 'Team skill data not available';
      setStatValue('teamskill', teamSkillValue);

      // Team skill requirements
      let teamConditionsValue = 'No requirements';
      if (teamSkill?.requirements) {
        const factionName = teamSkill.requirements.faction;
        const elementName = teamSkill.requirements.element;
        teamConditionsValue = `${factionName} + ${elementName}`;
      } else if (teamSkill) {
        // If team skill exists but no requirements, show character's own faction + element
        teamConditionsValue = `${character.faction} + ${character.element}`;
      }

      // Set the value safely
      const el = document.querySelector(`[data-stat="teamconditions-${columnIndex}"]`);
      if (el) {
        if (teamConditionsValue.includes('\n')) {
          const parts = teamConditionsValue.split('\n').filter(Boolean);
          el.innerHTML = '';
          parts.forEach((part, index) => {
            if (index > 0) el.appendChild(document.createElement('br'));
            el.appendChild(document.createTextNode(part.trim()));
          });
        } else {
          el.textContent = teamConditionsValue;
        }
        el.classList.add('active');
        el.style.display = 'block';
        el.style.visibility = 'visible';
      }
    }

    clearTableCells() {
      // Clear premium design elements
      for (let i = 1; i <= 4; i++) {
        const column = document.querySelector(`.premium-character-column[data-character="${i}"]`);
        if (column) {
          column.classList.remove('active');
          column.style.display = 'none';
        }

        // Clear all stat values for this column
        const statElements = document.querySelectorAll(`[data-stat$="-${i}"]`);

        statElements.forEach(el => {
          // For badge elements, we need to clear innerHTML to remove span elements
          if (el.classList.contains('stat-value-premium')) {
            el.innerHTML = '';
          } else {
            el.textContent = '';
          }
          el.classList.remove('active');
          el.style.display = 'none';
          el.style.visibility = 'hidden';
        });
      }
    }

    hideCharacterColumn(columnIndex) {
      const column = document.querySelector(
        `.premium-character-column[data-character="${columnIndex}"]`
      );
      if (column) {
        column.classList.remove('active');
        column.style.display = 'none';
      }

      // Hide all stat values for this column
      document.querySelectorAll(`[data-stat$="-${columnIndex}"]`).forEach(el => {
        // For badge elements, we need to clear innerHTML to remove span elements
        if (el.classList.contains('stat-value-premium')) {
          el.innerHTML = '';
        } else {
          el.textContent = '';
        }
        el.classList.remove('active');
        el.style.display = 'none';
        el.style.visibility = 'hidden';
      });
    }

    navigateToComparison() {
      const targetElement = document.getElementById('comparison-table');

      if (targetElement) {
        // Immediate scroll with minimal delay for DOM update
        requestAnimationFrame(() => {
          targetElement.scrollIntoView({
            behavior: 'smooth',
            block: 'start',
          });
        });
      }
    }

    clearComparison() {
      this.selectedCharacters = [];

      // Clear all selected states
      const characterCards = document.querySelectorAll('.character-select-card');

      characterCards.forEach(card => {
        card.dataset.selected = 'false';
        // Also remove visual selection class if it exists
        card.classList.remove('selected');
      });

      // Clear table cells
      this.clearTableCells();

      // Hide comparison table
      const comparisonTable = document.getElementById('comparison-table');
      if (comparisonTable) {
        comparisonTable.classList.remove('active');
      }

      // Clear mobile cards
      const mobileCardsContainer = document.getElementById('mobile-comparison-cards');
      if (mobileCardsContainer) {
        mobileCardsContainer.innerHTML = '';
      }
    }

    // Cleanup functions to prevent memory leaks
    cleanupCharacterCardListeners() {
      const characterCards = document.querySelectorAll('.character-select-card');
      characterCards.forEach(card => {
        const handler = this.characterCardListeners.get(card);
        if (handler) {
          card.removeEventListener('click', handler);
          this.characterCardListeners.delete(card);
        }
      });
    }

    cleanupFilterListeners() {
      // Clean up all tracked event listeners
      this.eventListeners.forEach((cleanupFn, _key) => {
        if (typeof cleanupFn === 'function') {
          cleanupFn();
        }
      });
      this.eventListeners.clear();
    }

    cleanup() {
      // Clear character card listeners
      this.cleanupCharacterCardListeners();

      // Clear filter listeners
      this.cleanupFilterListeners();

      // Clear caches
      this.characterDataCache.clear();
      this.selectedCharacters.length = 0;

      // Reset state
      this.sortState = { column: null, asc: false };
    }
  }

  // Initialize the comparison tool when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      window.zoneNovaCharacterComparison = new ZoneNovaCharacterComparison();
    });
  } else {
    // DOM is already ready
    window.zoneNovaCharacterComparison = new ZoneNovaCharacterComparison();
  }

  // Add cleanup on page unload to prevent memory leaks
  const cleanupHandler = () => {
    if (
      window.zoneNovaCharacterComparison &&
      typeof window.zoneNovaCharacterComparison.cleanup === 'function'
    ) {
      window.zoneNovaCharacterComparison.cleanup();
    }
  };

  window.addEventListener('beforeunload', cleanupHandler);
  window.addEventListener('pagehide', cleanupHandler);

  // Export cleanup function for manual cleanup
  window.ZONE_NOVA_COMPARISON_CLEANUP = cleanupHandler;
</script>
