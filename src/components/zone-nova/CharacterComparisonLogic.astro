---
// Import centralized Zone Nova data component
import { sanitizedCharacters } from './ZNCharacterData.astro';
---

<!-- Setup data BEFORE loading the script -->
<script define:vars={{ characterData: sanitizedCharacters }}>
  // Set up global data for the external comparison script
  window.zoneNovaComparisonData = {
    characterData: {
      characters: characterData.map(char => ({
        slug: char.slug,
        name: char.originalName,
        rarity: char.rarity,
        element: char.element,
        role: char.role,
        class: char.class,
        faction: char.faction,
        image: char.image,
        stats: char.stats || {},
      })),
    },
  };
</script>

<!-- Comparison script -->
<script type="module">
  /**
   * Zone Nova Character Comparison Tool
   * Secure, optimized character comparison functionality
   */

  class ZoneNovaCharacterComparison {
    constructor() {
      this.selectedCharacters = [];
      this.maxCharacters = 4;
      this.characterDataProcessed = null;
      this.filteredCharacters = [];
      this.sortState = { column: null, asc: false };
      this.characterDataCache = new Map();
      this.eventListeners = new Map();
      this.characterCardListeners = new WeakMap();

      this.init();
    }

    async init() {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => this.initializeApp());
      } else {
        this.initializeApp();
      }
    }

    initializeApp() {
      // Get data from window global (set by Astro)
      if (window.zoneNovaComparisonData) {
        this.characterDataProcessed = window.zoneNovaComparisonData.characterData;

        // Sort characters alphabetically by name for default order
        this.characterDataProcessed.characters.sort((a, b) => a.name.localeCompare(b.name));
        this.filteredCharacters = [...this.characterDataProcessed.characters];
      } else {
        // Zone Nova comparison data not found
        return;
      }

      this.initializeCharacterSelection();
      this.initializeComparisonControls();
      this.initializeFilterControls();
      this.renderCharacterGrid();
    }

    // Lazy loading helper for character data
    async loadCharacterData(slug) {
      // Input validation
      if (!slug || typeof slug !== 'string') {
        console.warn('Invalid character slug provided to loadCharacterData');
        return null;
      }

      if (this.characterDataCache.has(slug)) {
        return this.characterDataCache.get(slug);
      }

      try {
        // Import the centralized data component
        const module = await import('/src/components/zone-nova/ZNCharacterData.astro');

        // Get the character data from the CHARACTER_DATA_MAP
        let data = module.CHARACTER_DATA_MAP?.[slug];

        // If not found, try looking for any character data object with teamSkill
        if (!data) {
          data = Object.values(module).find(val => val && typeof val === 'object' && val.teamSkill);
        }

        // If still not found, try looking for any character data object
        if (!data) {
          data = Object.values(module).find(
            val => val && typeof val === 'object' && (val.name || val.skills)
          );
        }

        this.characterDataCache.set(slug, data || null);
        return data || null;
      } catch (error) {
        console.error(`Failed to load character data for ${slug}:`, error);
        this.characterDataCache.set(slug, null);
        return null;
      }
    }

    initializeCharacterSelection() {
      const characterCards = document.querySelectorAll('.character-select-card');
      console.log('Zone Nova Comparison: Found', characterCards.length, 'character cards');

      // Clean up existing listeners
      this.cleanupCharacterCardListeners();

      characterCards.forEach(card => {
        const cardClickHandler = () => {
          const characterSlug = card.dataset.characterSlug;
          console.log('Zone Nova Comparison: Card clicked:', characterSlug);

          // Input validation
          if (!characterSlug || typeof characterSlug !== 'string') {
            console.warn('Invalid character slug found on card');
            return;
          }

          const isSelected = card.dataset.selected === 'true';

          if (isSelected) {
            // Remove from selection
            this.selectedCharacters = this.selectedCharacters.filter(
              slug => slug !== characterSlug
            );
            card.dataset.selected = 'false';
          } else {
            // Add to selection - if at max, replace the oldest selection
            if (this.selectedCharacters.length < this.maxCharacters) {
              this.selectedCharacters.push(characterSlug);
              card.dataset.selected = 'true';
            } else {
              // Replace oldest selection with new one
              const oldestSlug = this.selectedCharacters.shift(); // Remove first (oldest)
              this.selectedCharacters.push(characterSlug); // Add new one

              // Update UI - unselect the old one
              const oldCard = document.querySelector(`[data-character-slug="${oldestSlug}"]`);
              if (oldCard) {
                oldCard.dataset.selected = 'false';
              }

              // Select the new one
              card.dataset.selected = 'true';
            }
          }

          this.updateComparisonTable();

          // Auto-navigate to comparison when 4 characters selected
          if (this.selectedCharacters.length === this.maxCharacters) {
            this.navigateToComparison();
          }
        };

        card.addEventListener('click', cardClickHandler);
        this.characterCardListeners.set(card, cardClickHandler);
      });
    }

    initializeComparisonControls() {
      const clearBtn = document.getElementById('clear-comparison');
      if (clearBtn) {
        const clearHandler = () => this.clearComparison();
        clearBtn.addEventListener('click', clearHandler);
        this.eventListeners.set('clear-comparison', () => {
          clearBtn.removeEventListener('click', clearHandler);
        });
      }
    }

    initializeFilterControls() {
      // Clean up existing filter listeners
      this.cleanupFilterListeners();

      const rarityFilter = document.getElementById('rarity-filter');
      const roleFilter = document.getElementById('role-filter');
      const classFilter = document.getElementById('class-filter');
      const elementFilter = document.getElementById('element-filter');
      const factionFilter = document.getElementById('faction-filter');
      const sortBtns = document.querySelectorAll('.sort-btn');
      const clearFiltersBtn = document.getElementById('clear-filters');

      // Filter listeners
      const filterHandler = () => this.applyFilters();

      if (rarityFilter) {
        rarityFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('rarity-filter', () => {
          rarityFilter.removeEventListener('change', filterHandler);
        });
      }

      if (roleFilter) {
        roleFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('role-filter', () => {
          roleFilter.removeEventListener('change', filterHandler);
        });
      }

      if (classFilter) {
        classFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('class-filter', () => {
          classFilter.removeEventListener('change', filterHandler);
        });
      }

      if (elementFilter) {
        elementFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('element-filter', () => {
          elementFilter.removeEventListener('change', filterHandler);
        });
      }

      if (factionFilter) {
        factionFilter.addEventListener('change', filterHandler);
        this.eventListeners.set('faction-filter', () => {
          factionFilter.removeEventListener('change', filterHandler);
        });
      }

      // Sort button listeners
      sortBtns.forEach(btn => {
        const sortHandler = () => {
          const col = btn.dataset.sort;
          // Input validation
          if (!col || typeof col !== 'string') {
            console.warn('Invalid sort column:', col);
            return;
          }

          // Toggle sort direction if same column, otherwise start with ascending
          this.sortState.asc = this.sortState.column === col ? !this.sortState.asc : true;
          this.sortState.column = col;

          // Update button states
          sortBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          this.applyFilters();
        };

        btn.addEventListener('click', sortHandler);
        this.eventListeners.set(`sort-${btn.dataset.sort}`, () => {
          btn.removeEventListener('click', sortHandler);
        });
      });

      if (clearFiltersBtn) {
        const clearFiltersHandler = () => this.clearFilters();
        clearFiltersBtn.addEventListener('click', clearFiltersHandler);
        this.eventListeners.set('clear-filters', () => {
          clearFiltersBtn.removeEventListener('click', clearFiltersHandler);
        });
      }
    }

    applyFilters() {
      const rarityFilter = document.getElementById('rarity-filter')?.value || '';
      const roleFilter = document.getElementById('role-filter')?.value || '';
      const classFilter = document.getElementById('class-filter')?.value || '';
      const elementFilter = document.getElementById('element-filter')?.value || '';
      const factionFilter = document.getElementById('faction-filter')?.value || '';

      // Filter characters
      this.filteredCharacters = this.characterDataProcessed.characters.filter(character => {
        const matchesRarity = !rarityFilter || character.rarity === rarityFilter;
        const matchesRole = !roleFilter || character.role === roleFilter;
        const matchesClass = !classFilter || character.class === classFilter;
        const matchesElement = !elementFilter || character.element === elementFilter;
        const matchesFaction = !factionFilter || character.faction === factionFilter;

        return matchesRarity && matchesRole && matchesClass && matchesElement && matchesFaction;
      });

      // Sort characters if a sort is active
      if (this.sortState.column) {
        this.sortCharacters(this.sortState.column, this.sortState.asc);
      }

      // Re-render grid
      this.renderCharacterGrid();
    }

    sortCharacters(sortOption, ascending) {
      this.filteredCharacters.sort((a, b) => {
        const aStats = a.stats || {};
        const bStats = b.stats || {};

        let comparison = 0;
        switch (sortOption) {
          case 'hp':
            comparison = (bStats.hp || 0) - (aStats.hp || 0);
            break;
          case 'attack':
            comparison = (bStats.attack || 0) - (aStats.attack || 0);
            break;
          case 'defense':
            comparison = (bStats.defense || 0) - (aStats.defense || 0);
            break;
          case 'critRate':
            comparison = (bStats.critRate || 0) - (aStats.critRate || 0);
            break;
          default:
            comparison = 0;
        }

        // Apply direction multiplier
        return ascending ? comparison : -comparison;
      });
    }

    clearFilters() {
      const filters = [
        'rarity-filter',
        'role-filter',
        'class-filter',
        'element-filter',
        'faction-filter',
      ];
      filters.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.value = '';
      });

      // Clear active sort button and reset sort state
      document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
      this.sortState = { column: null, asc: false };

      // Reset to alphabetical order (same as initial load)
      this.filteredCharacters = [...this.characterDataProcessed.characters].sort((a, b) =>
        a.name.localeCompare(b.name)
      );
      this.renderCharacterGrid();
    }

    renderCharacterGrid() {
      const characterGrid = document.querySelector('.character-grid');
      if (!characterGrid) return;

      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      const characterCards = this.filteredCharacters
        .map(character => {
          // Input validation
          if (!character || typeof character !== 'object') {
            console.warn('Invalid character data found:', character);
            return null;
          }

          const stats = character.stats || {};

          const cardElement = document.createElement('button');
          cardElement.className = 'character-select-card';
          cardElement.dataset.characterSlug = character.slug || '';
          cardElement.dataset.selected = this.selectedCharacters.includes(character.slug);

          // Create elements safely without innerHTML to prevent XSS
          const img = document.createElement('img');
          img.src = character.image || '/images/placeholder.png';
          img.alt = character.name || 'Unknown Character';
          img.className = 'character-portrait';
          img.width = 80;
          img.height = 80;
          img.onerror = function () {
            this.src = '/images/placeholder.png';
          };

          const characterInfo = document.createElement('div');
          characterInfo.className = 'character-info';

          const h3 = document.createElement('h3');
          h3.textContent = character.name || 'Unknown';

          const badgesDiv = document.createElement('div');
          badgesDiv.className = 'character-badges';

          const rarityBadge = document.createElement('span');
          rarityBadge.className = `rarity-badge ${(character.rarity || '').toLowerCase()}`;
          rarityBadge.textContent = character.rarity || 'Unknown';

          const classBadge = document.createElement('span');
          classBadge.className = `class-badge ${(character.class || 'unknown').toLowerCase().replace(' ', '-')}`;
          classBadge.textContent = character.class || 'Unknown';

          const elementBadge = document.createElement('span');
          elementBadge.className = `element-badge ${(character.element || '').toLowerCase()}`;
          elementBadge.textContent = character.element || 'Unknown';

          const roleBadge = document.createElement('span');
          roleBadge.className = `role-badge ${(character.role || '').toLowerCase()}`;
          roleBadge.textContent = character.role || 'Unknown';

          const factionBadge = document.createElement('span');
          factionBadge.className = `faction-badge ${(character.faction || '').toLowerCase().replace(' ', '-')}`;
          factionBadge.textContent = character.faction || 'Unknown';

          const statsDiv = document.createElement('div');
          statsDiv.className = 'character-stats';

          // HP stat
          const hpDiv = document.createElement('div');
          hpDiv.className = 'stat-item';
          const hpLabel = document.createElement('span');
          hpLabel.className = 'stat-label';
          hpLabel.textContent = 'HP';
          const hpValue = document.createElement('span');
          hpValue.className = 'stat-value';
          hpValue.textContent =
            stats.hp !== undefined
              ? typeof stats.hp === 'string'
                ? stats.hp
                : stats.hp.toLocaleString()
              : 'N/A';
          hpDiv.appendChild(hpLabel);
          hpDiv.appendChild(hpValue);

          // ATK stat
          const atkDiv = document.createElement('div');
          atkDiv.className = 'stat-item';
          const atkLabel = document.createElement('span');
          atkLabel.className = 'stat-label';
          atkLabel.textContent = 'ATK';
          const atkValue = document.createElement('span');
          atkValue.className = 'stat-value';
          atkValue.textContent =
            stats.attack !== undefined
              ? typeof stats.attack === 'string'
                ? stats.attack
                : stats.attack.toLocaleString()
              : 'N/A';
          atkDiv.appendChild(atkLabel);
          atkDiv.appendChild(atkValue);

          // DEF stat
          const defDiv = document.createElement('div');
          defDiv.className = 'stat-item';
          const defLabel = document.createElement('span');
          defLabel.className = 'stat-label';
          defLabel.textContent = 'DEF';
          const defValue = document.createElement('span');
          defValue.className = 'stat-value';
          defValue.textContent =
            stats.defense !== undefined
              ? typeof stats.defense === 'string'
                ? stats.defense
                : stats.defense.toLocaleString()
              : 'N/A';
          defDiv.appendChild(defLabel);
          defDiv.appendChild(defValue);

          // CRIT stat if available
          if (stats.critRate !== undefined) {
            const critDiv = document.createElement('div');
            critDiv.className = 'stat-item crit-rate';
            const critLabel = document.createElement('span');
            critLabel.className = 'stat-label';
            critLabel.textContent = 'CRIT';
            const critValue = document.createElement('span');
            critValue.className = 'stat-value';
            critValue.textContent =
              typeof stats.critRate === 'string' ? stats.critRate : `${stats.critRate}%`;
            critDiv.appendChild(critLabel);
            critDiv.appendChild(critValue);
            statsDiv.appendChild(critDiv);
          }

          // Assemble elements
          badgesDiv.appendChild(rarityBadge);
          badgesDiv.appendChild(classBadge);
          badgesDiv.appendChild(elementBadge);
          badgesDiv.appendChild(roleBadge);
          badgesDiv.appendChild(factionBadge);
          statsDiv.appendChild(hpDiv);
          statsDiv.appendChild(atkDiv);
          statsDiv.appendChild(defDiv);
          characterInfo.appendChild(h3);
          characterInfo.appendChild(badgesDiv);
          characterInfo.appendChild(statsDiv);
          cardElement.appendChild(img);
          cardElement.appendChild(characterInfo);

          return cardElement;
        })
        .filter(Boolean); // Remove any null cards

      // Clear grid safely and append new elements
      while (characterGrid.firstChild) {
        characterGrid.removeChild(characterGrid.firstChild);
      }

      characterCards.forEach(card => fragment.appendChild(card));
      characterGrid.appendChild(fragment);

      // Re-initialize selection functionality
      this.initializeCharacterSelection();
    }

    async updateComparisonTable() {
      const comparisonTable = document.getElementById('comparison-table');
      if (!comparisonTable) return;

      if (this.selectedCharacters.length === 0) {
        comparisonTable.classList.remove('active');
        return;
      }

      comparisonTable.classList.add('active');

      // Clear existing data
      this.clearTableCells();

      // Populate table with selected characters
      const populationPromises = this.selectedCharacters.map(async (characterSlug, index) => {
        const character = this.characterDataProcessed.characters.find(
          c => c.slug === characterSlug
        );
        if (character) {
          await this.populateCharacterColumn(character, index + 1);
        }
      });

      await Promise.all(populationPromises);

      // Hide unused columns
      for (let i = this.selectedCharacters.length + 1; i <= this.maxCharacters; i++) {
        this.hideCharacterColumn(i);
      }
    }

    async populateCharacterColumn(character, columnIndex) {
      // Show character column
      const column = document.querySelector(
        `.premium-character-column[data-character="${columnIndex}"]`
      );
      if (column) {
        column.classList.add('active');
        column.style.display = 'block';
      }

      // Populate character header
      const portrait = document.querySelector(`.premium-portrait[data-portrait="${columnIndex}"]`);
      if (portrait) {
        portrait.src = character.image;
        portrait.alt = character.name;
      }

      const nameEl = document.querySelector(`.character-name[data-name="${columnIndex}"]`);
      if (nameEl) {
        nameEl.textContent = character.name;
      }

      // Populate stats
      const stats = character.stats || {};

      const setStatValue = (statName, value) => {
        const el = document.querySelector(`[data-stat="${statName}-${columnIndex}"]`);
        if (el) {
          el.textContent = value;
          el.classList.add('active');
          el.style.display = 'block';
        }
      };

      const setBadgeValue = (statName, value, badgeType) => {
        const el = document.querySelector(`[data-stat="${statName}-${columnIndex}"]`);
        if (el) {
          // Handle long faction names
          let displayValue = value;
          if (badgeType === 'faction' && value.length > 12) {
            const abbreviations = {
              'Monochrome Nation': 'Mono Nation',
              'Pingjing City': 'Pingjing',
              'Bicta Tower': 'Bicta',
            };
            displayValue = abbreviations[value] || value;
          }

          const span = document.createElement('span');
          span.className = `${badgeType}-badge ${value.toLowerCase().replace(/\s+/g, '-')}`;
          span.textContent = displayValue;
          el.innerHTML = '';
          el.appendChild(span);
          el.classList.add('active');
          el.style.display = 'block';
        }
      };

      setBadgeValue('rarity', character.rarity, 'rarity');
      setBadgeValue('class', character.class, 'class');
      setBadgeValue('role', character.role, 'role');
      setBadgeValue('faction', character.faction, 'faction');
      setBadgeValue('element', character.element, 'element');

      // Load team skill data lazily and get detailed stats
      const characterData = await this.loadCharacterData(character.slug);
      const detailedStats = characterData?.stats || stats;

      // Combat stats - prioritize detailed character data, fallback to basic stats
      const hp = detailedStats.hp || stats.hp;
      const attack = detailedStats.attack || stats.attack;
      const defense = detailedStats.defense || stats.defense;
      const energy =
        detailedStats.energyRegen || detailedStats.energyRecovery || stats.energyRecovery;
      const critRate = detailedStats.critRate || stats.critRate;
      const critDmg = detailedStats.critDamage || detailedStats.critDmg || stats.critDmg;

      setStatValue(
        'hp',
        hp !== undefined ? (typeof hp === 'string' ? hp : hp.toLocaleString()) : 'N/A'
      );
      setStatValue(
        'attack',
        attack !== undefined
          ? typeof attack === 'string'
            ? attack
            : attack.toLocaleString()
          : 'N/A'
      );
      setStatValue(
        'defense',
        defense !== undefined
          ? typeof defense === 'string'
            ? defense
            : defense.toLocaleString()
          : 'N/A'
      );
      setStatValue(
        'energy',
        energy !== undefined ? (typeof energy === 'string' ? energy : energy) : 'N/A'
      );
      setStatValue(
        'crit',
        critRate !== undefined ? (typeof critRate === 'string' ? critRate : critRate + '%') : 'N/A'
      );
      setStatValue(
        'critdmg',
        critDmg !== undefined ? (typeof critDmg === 'string' ? critDmg : critDmg + '%') : 'N/A'
      );

      const teamSkill = characterData?.teamSkill;

      // Team skill name
      const teamSkillName = teamSkill?.name || 'No team skill';
      setStatValue('teamskillname', teamSkillName);

      // Team skill description
      const teamSkillValue = teamSkill?.description || 'No team skill available';
      setStatValue('teamskill', teamSkillValue);

      // Team skill requirements with better formatting
      let teamConditionsValue = 'No requirements';
      if (teamSkill?.requirements) {
        const factionName = teamSkill.requirements.faction;
        const elementName = teamSkill.requirements.element;

        if (factionName.length > 8) {
          teamConditionsValue = `${factionName}\n${elementName}`;
        } else {
          teamConditionsValue = `${factionName} + ${elementName}`;
        }
      }

      // Set the value safely
      const el = document.querySelector(`[data-stat="teamconditions-${columnIndex}"]`);
      if (el) {
        if (teamConditionsValue.includes('\n')) {
          const parts = teamConditionsValue.split('\n').filter(Boolean);
          el.innerHTML = '';
          parts.forEach((part, index) => {
            if (index > 0) el.appendChild(document.createElement('br'));
            el.appendChild(document.createTextNode(part.trim()));
          });
        } else {
          el.textContent = teamConditionsValue;
        }
        el.classList.add('active');
        el.style.display = 'block';
      }
    }

    clearTableCells() {
      // Clear premium design elements
      for (let i = 1; i <= 4; i++) {
        const column = document.querySelector(`.premium-character-column[data-character="${i}"]`);
        if (column) {
          column.classList.remove('active');
          column.style.display = 'none';
        }

        // Clear all stat values for this column
        document.querySelectorAll(`[data-stat$="-${i}"]`).forEach(el => {
          el.textContent = '';
          el.classList.remove('active');
          el.style.display = 'none';
        });
      }
    }

    hideCharacterColumn(columnIndex) {
      const column = document.querySelector(
        `.premium-character-column[data-character="${columnIndex}"]`
      );
      if (column) {
        column.classList.remove('active');
        column.style.display = 'none';
      }

      // Hide all stat values for this column
      document.querySelectorAll(`[data-stat$="-${columnIndex}"]`).forEach(el => {
        el.classList.remove('active');
        el.style.display = 'none';
      });
    }

    navigateToComparison() {
      const comparisonSection = document.getElementById('comparison-table');
      if (comparisonSection) {
        // Immediate scroll with minimal delay for DOM update
        requestAnimationFrame(() => {
          comparisonSection.scrollIntoView({
            behavior: 'smooth',
            block: 'start',
          });
        });
      }
    }

    clearComparison() {
      this.selectedCharacters = [];

      // Clear all selected states
      const characterCards = document.querySelectorAll('.character-select-card');
      characterCards.forEach(card => {
        card.dataset.selected = 'false';
      });

      // Hide comparison table
      const comparisonTable = document.getElementById('comparison-table');
      if (comparisonTable) {
        comparisonTable.classList.remove('active');
      }
    }

    // Cleanup functions to prevent memory leaks
    cleanupCharacterCardListeners() {
      const characterCards = document.querySelectorAll('.character-select-card');
      characterCards.forEach(card => {
        const handler = this.characterCardListeners.get(card);
        if (handler) {
          card.removeEventListener('click', handler);
          this.characterCardListeners.delete(card);
        }
      });
    }

    cleanupFilterListeners() {
      // Clean up all tracked event listeners
      this.eventListeners.forEach((cleanupFn, key) => {
        if (typeof cleanupFn === 'function') {
          cleanupFn();
        }
      });
      this.eventListeners.clear();
    }

    cleanup() {
      console.log('Zone Nova Comparison: Cleaning up resources...');

      // Clear character card listeners
      this.cleanupCharacterCardListeners();

      // Clear filter listeners
      this.cleanupFilterListeners();

      // Clear caches
      this.characterDataCache.clear();
      this.selectedCharacters.length = 0;
      this.filteredCharacters.length = 0;

      // Reset state
      this.sortState = { column: null, asc: false };
      this.characterDataProcessed = null;

      console.log('Zone Nova Comparison: Cleanup completed');
    }
  }

  // Initialize the comparison tool when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      window.zoneNovaCharacterComparison = new ZoneNovaCharacterComparison();
    });
  } else {
    // DOM is already ready
    window.zoneNovaCharacterComparison = new ZoneNovaCharacterComparison();
  }

  // Add cleanup on page unload to prevent memory leaks
  const cleanupHandler = () => {
    if (
      window.zoneNovaCharacterComparison &&
      typeof window.zoneNovaCharacterComparison.cleanup === 'function'
    ) {
      window.zoneNovaCharacterComparison.cleanup();
    }
  };

  window.addEventListener('beforeunload', cleanupHandler);
  window.addEventListener('pagehide', cleanupHandler);

  // Export cleanup function for manual cleanup
  window.ZONE_NOVA_COMPARISON_CLEANUP = cleanupHandler;
</script>
