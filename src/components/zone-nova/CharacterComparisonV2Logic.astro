---
// Import centralized Zone Nova data component
import {
  sanitizedCharacters,
  roles,
  classes,
  elements,
  factions,
  rarities,
  PVE_TIER_LIST,
  PVP_TIER_LIST,
  RIFT_TIER_LIST,
  GUILD_RAID_TIER_LIST,
  NEW_PLAYER_TIER_LIST,
  rankings,
  overallAnalysis,
  CHARACTER_DATA_MAP,
} from './ZNCharacterData.astro';
---

<!-- Setup data BEFORE loading the script -->
<script
  define:vars={{
    characterData: sanitizedCharacters,
    pveTier: PVE_TIER_LIST,
    pvpTier: PVP_TIER_LIST,
    riftTier: RIFT_TIER_LIST,
    guildTier: GUILD_RAID_TIER_LIST,
    newPlayerTier: NEW_PLAYER_TIER_LIST,
    rankingsData: rankings,
    overallAnalysisData: overallAnalysis,
    roles,
    classes,
    elements,
    factions,
    rarities,
    characterDataMap: CHARACTER_DATA_MAP,
  }}
>
  // Security: Freeze objects to prevent prototype pollution
  // Make character data available to inline JS
  window.ZN_COMPARISON_V2_DATA = Object.freeze({
    characters: Object.freeze([...characterData]),
    tierLists: Object.freeze({
      pve: Object.freeze(pveTier),
      pvp: Object.freeze(pvpTier),
      rift: Object.freeze(riftTier),
      guild: Object.freeze(guildTier),
      newPlayer: Object.freeze(newPlayerTier),
    }),
    rankings: Object.freeze(rankingsData),
    overallAnalysis: Object.freeze(overallAnalysisData),
    filterOptions: Object.freeze({
      roles: Object.freeze(roles),
      classes: Object.freeze(classes),
      elements: Object.freeze(elements),
      factions: Object.freeze(factions),
      rarities: Object.freeze(rarities),
    }),
    characterDataMap: Object.freeze(characterDataMap),
  });
</script>

<!-- Load external JS AFTER data is set up -->
<script type="module">
  // Zone Nova Character Comparison V2 - Card-based System
  // JavaScript logic for character selection, card management, and comparison functionality
  // No animations or hover effects as requested
  //
  // Security: All user inputs are sanitized, no eval() usage, safe DOM manipulation

  'use strict';

  // Global state - using const where possible for immutability
  const selectedCharacters = [];
  let filteredCharacters = [];
  const characterDataMap = new Map(); // Use Map for better performance
  const MAX_CHARACTERS = 2;

  // Constants for magic numbers
  const SEARCH_DEBOUNCE_MS = 150;
  const NOTIFICATION_DURATION_MS = 3000;
  const FOCUS_DELAY_MS = 100;

  // Store global functions in a namespace to avoid pollution
  const ZNComparisonV2 = {
    getCurrentMobileSlot: null,
    closeMobileModal: null,
    searchTimeout: null,
    activeAbortControllers: new Set(),
  };

  // Cache DOM elements and event listeners to avoid repeated queries and memory leaks
  const domCache = {
    iconsContainer: null,
    selectedCount: null,
    emptyMessage: null,
    comparisonContainer: null,
    cardsGrid: null,
    initialized: false,
  };

  // Track event listeners for cleanup
  const eventListeners = new Map();
  const cardEventListeners = new WeakMap();

  /**
   * Get character tiers from all tier lists
   * @param {string} characterName - The character name to lookup
   * @returns {Object} Object containing tier for each list type
   */
  function getCharacterTiers(characterName) {
    // Input validation
    if (!characterName || typeof characterName !== 'string') return {};
    if (!window.ZN_COMPARISON_V2_DATA?.tierLists) return {};

    const { tierLists } = window.ZN_COMPARISON_V2_DATA;
    const result = {};

    // Use for...of for better performance than Object.keys().forEach()
    for (const [listKey, tierList] of Object.entries(tierLists)) {
      if (!tierList?.tiers) continue;

      let tier = 'Unranked';
      // Break early when found for performance
      for (const [tierKey, characters] of Object.entries(tierList.tiers)) {
        if (Array.isArray(characters) && characters.some(char => char.name === characterName)) {
          tier = tierKey;
          break;
        }
      }
      result[listKey] = tier;
    }

    return result;
  }

  /**
   * Get character stat rankings
   * @param {string|number} characterId - The character ID to lookup
   * @returns {Object} Object containing rankings for each stat
   */
  function getCharacterRankings(characterId) {
    // Input validation - handle both string and number IDs
    if (!characterId && characterId !== 0) return {};
    if (!window.ZN_COMPARISON_V2_DATA?.rankings) return {};

    const { rankings } = window.ZN_COMPARISON_V2_DATA;
    const result = {};
    const STAT_TYPES = ['hp', 'attack', 'defense']; // Constant array

    // Convert to string for object key lookup
    const keyId = String(characterId);

    for (const stat of STAT_TYPES) {
      const rankValue = rankings[stat]?.[keyId];
      result[stat] = rankValue !== undefined ? rankValue : 'N/A';
    }

    return result;
  }

  /**
   * Calculate overall rank from individual stat rankings
   * @param {Object} rankings - Rankings object with hp, attack, defense
   * @returns {string} Calculated overall rank or 'N/A'
   */
  function calculateOverallRank(rankings) {
    const { hp, attack, defense } = rankings;

    // Check if all rankings are valid numbers
    const hpRank = parseFloat(hp);
    const atkRank = parseFloat(attack);
    const defRank = parseFloat(defense);

    if (isNaN(hpRank) || isNaN(atkRank) || isNaN(defRank)) {
      return 'N/A';
    }

    // Calculate average rank and round to nearest integer
    const averageRank = Math.round((hpRank + atkRank + defRank) / 3);
    return String(averageRank);
  }

  /**
   * Get competitive overall rank from overallAnalysis data with fallback
   * @param {number} characterId - The character ID to look up
   * @param {Object} rankings - Rankings data for fallback calculation
   * @returns {string} Competitive overall rank or calculated rank
   */
  function getCompetitiveOverallRank(characterId, rankings = {}) {
    // First, try to get competitive rank from overallAnalysis
    if (window.ZN_COMPARISON_V2_DATA?.overallAnalysis && characterId) {
      const overallRank = window.ZN_COMPARISON_V2_DATA.overallAnalysis[characterId]?.overallRank;

      if (overallRank !== undefined && overallRank !== null) {
        return String(overallRank);
      }
    }

    // Fallback: use the old calculation method if overallAnalysis is missing
    if (rankings && Object.keys(rankings).length > 0) {
      return calculateOverallRank(rankings);
    }

    return 'N/A';
  }

  /**
   * Format rank value for display
   * @param {any} rankValue - The rank value to format
   * @returns {string} Formatted rank value
   */
  function formatRankValue(rankValue) {
    if (rankValue === undefined || rankValue === null || rankValue === 'N/A') {
      return 'N/A';
    }

    const numericRank = parseFloat(rankValue);
    if (isNaN(numericRank)) {
      return 'N/A';
    }

    return String(Math.round(numericRank));
  }

  // Initialize when DOM is loaded - using arrow function for consistency
  document.addEventListener('DOMContentLoaded', () => {
    initializeComparisonV2();
  });

  /**
   * Initialize the V2 comparison system
   * @returns {void}
   */
  function initializeComparisonV2() {
    try {
      // Validate required data
      if (!window.ZN_COMPARISON_V2_DATA?.characters) {
        throw new Error('Character data not available');
      }

      // Validate additional data structures
      if (!window.ZN_COMPARISON_V2_DATA?.rankings) {
        console.warn('Rankings data not available - some features may not work');
      }

      if (!window.ZN_COMPARISON_V2_DATA?.overallAnalysis) {
        console.warn('Overall analysis data not available - falling back to calculated rankings');
      }

      // Initialize DOM cache
      initializeDOMCache();

      // Set up initial data - defensive copy
      filteredCharacters = [...window.ZN_COMPARISON_V2_DATA.characters];

      // Initialize event listeners
      initializeFilters();
      initializeDeckInteractions();
      initializeMobileModal();
      initializeArenaControls();
      initializeKeyboardNavigation();

      // Render initial state
      updateIconStates();
      updateSelectedCount();
    } catch (error) {
      console.error('Failed to initialize comparison V2:', error);
      showErrorMessage('Failed to load character comparison. Please refresh the page.');
    }
  }

  /**
   * Initialize DOM element cache for performance
   * @returns {void}
   */
  function initializeDOMCache() {
    domCache.iconsContainer = document.getElementById('v2-character-icons');
    domCache.selectedCount = document.getElementById('v2-selected-count');
    domCache.emptyMessage = document.getElementById('v2-empty-message');
    domCache.comparisonContainer = document.getElementById('v2-comparison-container');
    domCache.cardsGrid = document.getElementById('v2-cards-grid');
    domCache.initialized = true;
  }

  /**
   * Show error message to user
   * @param {string} message - Error message to display
   * @returns {void}
   */
  function showErrorMessage(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    errorDiv.setAttribute('role', 'alert');
    errorDiv.setAttribute('aria-live', 'assertive');

    const container = document.querySelector('.comparison-container') || document.body;
    container.insertBefore(errorDiv, container.firstChild);

    // Auto-remove after duration
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, NOTIFICATION_DURATION_MS * 2);
  }

  /**
   * Initialize filter event listeners
   */
  function initializeFilters() {
    const roleFilter = document.getElementById('v2-role-filter');
    const classFilter = document.getElementById('v2-class-filter');
    const rarityFilter = document.getElementById('v2-rarity-filter');
    const elementFilter = document.getElementById('v2-element-filter');
    const factionFilter = document.getElementById('v2-faction-filter');
    const resetBtn = document.getElementById('v2-reset-filters');

    [roleFilter, classFilter, rarityFilter, elementFilter, factionFilter].forEach(filter => {
      if (filter) {
        filter.addEventListener('change', applyFilters);
      }
    });

    if (resetBtn) {
      resetBtn.addEventListener('click', resetFilters);
    }
  }

  /**
   * Initialize character icon interactions
   * @returns {void}
   */
  function initializeDeckInteractions() {
    const iconsContainer = domCache.iconsContainer || document.getElementById('v2-character-icons');
    if (iconsContainer) {
      console.log('Initializing deck interactions on container:', iconsContainer);
      iconsContainer.addEventListener('click', handleIconClick);
      console.log('Event listener added to icons container');
    } else {
      console.error('Icons container not found during initialization');
    }
  }

  /**
   * Initialize mobile modal interactions for character selection
   */
  function initializeMobileModal() {
    const modal = document.getElementById('v2-mobile-modal');
    const selectButton1 = document.getElementById('v2-mobile-select-1');
    const selectButton2 = document.getElementById('v2-mobile-select-2');

    // Track current slot being selected
    let currentSelectionSlot = null;

    // Initialize selection buttons
    if (selectButton1) {
      selectButton1.addEventListener('click', () => openMobileModal(1));
    }
    if (selectButton2) {
      selectButton2.addEventListener('click', () => openMobileModal(2));
    }

    // Initialize modal controls once
    initializeModalControls(modal);
    initializeModalSearch();
    initializeModalFilters();
    initializeModalCharacterGrid();

    // Store current slot getter in namespace
    ZNComparisonV2.getCurrentMobileSlot = () => currentSelectionSlot;

    function openMobileModal(slotNumber) {
      if (!modal) return;

      currentSelectionSlot = slotNumber;
      const modalTitle = document.getElementById('v2-modal-title');

      if (modalTitle) {
        modalTitle.textContent = `Select Character ${slotNumber}`;
      }

      // Reset search to show all characters
      const searchInput = document.getElementById('v2-modal-search');
      if (searchInput) {
        searchInput.value = '';
      }

      // Update character grid - show all characters and update selection states
      updateModalCharacterGrid('');
      updateModalCharacterStates();

      // Open modal
      modal.classList.add('open');

      document.body.style.overflow = 'hidden';

      // Focus search input for better UX
      if (searchInput) {
        setTimeout(() => searchInput.focus(), FOCUS_DELAY_MS);
      }
    }

    function closeModal() {
      if (!modal) return;

      modal.classList.remove('open');

      document.body.style.overflow = '';

      currentSelectionSlot = null;

      // Clear search when closing
      const searchInput = document.getElementById('v2-modal-search');
      if (searchInput) {
        searchInput.value = '';
      }
      updateModalCharacterGrid();
    }

    // Store close function in namespace
    ZNComparisonV2.closeMobileModal = closeModal;
  }

  /**
   * Initialize arena control buttons
   */
  function initializeArenaControls() {
    const clearAllBtn = document.getElementById('v2-clear-all');
    if (clearAllBtn) {
      clearAllBtn.addEventListener('click', clearAllCharacters);
    }
  }

  /**
   * Handle clicking on character icons
   * @param {Event} event - Click event
   * @returns {void}
   */
  function handleIconClick(event) {
    event.preventDefault(); // Prevent any default behavior
    console.log('Icon clicked!', event.target);

    const icon = event.target.closest('.character-icon');
    if (!icon) {
      console.log('No parent character-icon found');
      return;
    }

    const characterSlug = icon.dataset.characterSlug;
    console.log('Character slug:', characterSlug);
    if (!characterSlug) {
      // Character slug not found on icon element
      console.log('Character slug not found on icon element');
      return;
    }

    if (icon.classList.contains('selected')) {
      console.log('Removing character:', characterSlug);
      removeCharacter(characterSlug);
    } else {
      console.log('Adding character:', characterSlug);
      addCharacter(characterSlug);
    }
  }

  /**
   * Add character to comparison
   * @param {string} characterSlug - The character slug to add
   * @returns {boolean} Success status
   */
  function addCharacter(characterSlug) {
    // Input validation
    if (!characterSlug || typeof characterSlug !== 'string') {
      // Invalid character slug provided to addCharacter
      return false;
    }

    if (selectedCharacters.includes(characterSlug)) return false;

    if (selectedCharacters.length >= MAX_CHARACTERS) {
      // Use more user-friendly notification instead of alert()
      showNotification(
        `You can only compare up to ${MAX_CHARACTERS} characters at once.`,
        'warning'
      );
      return false;
    }

    selectedCharacters.push(characterSlug);

    // Single batch update
    updateAllDisplays();

    // Load character data lazily
    loadCharacterData(characterSlug);

    // Auto-scroll to comparison section when 2 characters are selected (desktop only)
    if (selectedCharacters.length === MAX_CHARACTERS && window.innerWidth > 768) {
      setTimeout(() => {
        const comparisonContainer = document.getElementById('v2-comparison-container');
        if (comparisonContainer && !comparisonContainer.classList.contains('hidden')) {
          comparisonContainer.scrollIntoView({
            behavior: 'smooth',
            block: 'start',
            inline: 'nearest',
          });
        }
      }, 100); // Small delay to ensure DOM is updated
    }

    return true;
  }

  /**
   * Show user notification
   * @param {string} message - Message to display
   * @param {string} type - Notification type (info, warning, error)
   * @returns {void}
   */
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    notification.setAttribute('role', 'status');
    notification.setAttribute('aria-live', 'polite');

    document.body.appendChild(notification);

    // Auto-remove after duration
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, NOTIFICATION_DURATION_MS);
  }

  /**
   * Remove character from comparison
   * @param {string} characterSlug - The character slug to remove
   * @returns {boolean} Success status
   */
  function removeCharacter(characterSlug) {
    // Input validation
    if (!characterSlug || typeof characterSlug !== 'string') {
      // Invalid character slug provided to removeCharacter
      return false;
    }

    const index = selectedCharacters.indexOf(characterSlug);

    if (index > -1) {
      selectedCharacters.splice(index, 1);

      // Single batch update
      updateAllDisplays();

      return true;
    }

    return false;
  }

  /**
   * Clear all selected characters
   * @returns {void}
   */
  function clearAllCharacters() {
    if (selectedCharacters.length === 0) return; // Early exit if already empty

    selectedCharacters.length = 0; // More efficient than reassignment

    // Single batch update
    updateAllDisplays();
  }

  /**
   * Apply filters to character deck
   * @returns {void}
   */
  function applyFilters() {
    try {
      // Get filter values with null checks
      const filters = {
        role: document.getElementById('v2-role-filter')?.value || '',
        class: document.getElementById('v2-class-filter')?.value || '',
        rarity: document.getElementById('v2-rarity-filter')?.value || '',
        element: document.getElementById('v2-element-filter')?.value || '',
        faction: document.getElementById('v2-faction-filter')?.value || '',
      };

      if (!window.ZN_COMPARISON_V2_DATA?.characters) {
        // Character data not available for filtering
        return;
      }

      filteredCharacters = window.ZN_COMPARISON_V2_DATA.characters.filter(character => {
        if (!character) return false;

        return (
          (!filters.role || character.role === filters.role) &&
          (!filters.class || character.class === filters.class) &&
          (!filters.rarity || character.rarity === filters.rarity) &&
          (!filters.element || character.element === filters.element) &&
          (!filters.faction || character.faction === filters.faction)
        );
      });

      updateIconStates();
    } catch (error) {
      console.error('Error applying filters:', error);
    }
  }

  /**
   * Reset all filters
   * @returns {void}
   */
  function resetFilters() {
    try {
      const filterIds = [
        'v2-role-filter',
        'v2-class-filter',
        'v2-rarity-filter',
        'v2-element-filter',
        'v2-faction-filter',
      ];

      filterIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) element.value = '';
      });

      if (window.ZN_COMPARISON_V2_DATA?.characters) {
        filteredCharacters = [...window.ZN_COMPARISON_V2_DATA.characters];
        updateIconStates();
      }
    } catch (error) {
      console.error('Error resetting filters:', error);
    }
  }

  /**
   * Update character icon states (selection and filtering)
   */
  function updateIconStates() {
    // Use cached container if available
    const container = domCache.iconsContainer || document.getElementById('v2-character-icons');
    if (!container) {
      console.warn('Character icons container not found');
      return;
    }

    const icons = container.querySelectorAll('.character-icon');
    console.log(
      `Found ${icons.length} character icons, filteredCharacters count: ${filteredCharacters.length}`
    );

    const filteredSlugs = new Set(filteredCharacters.map(char => char.slug));

    icons.forEach(icon => {
      const characterSlug = icon.dataset.characterSlug;
      const isSelected = selectedCharacters.includes(characterSlug);
      const isFiltered = filteredSlugs.has(characterSlug);

      console.log(`Character ${characterSlug}: selected=${isSelected}, isFiltered=${isFiltered}`);

      // Update selection state
      icon.classList.toggle('selected', isSelected);

      // Update filter state
      icon.classList.toggle('filtered-out', !isFiltered);
    });
  }

  /**
   * Update the comparison container
   * @returns {void}
   */
  function updateComparisonContainer() {
    const emptyMessage = domCache.emptyMessage || document.getElementById('v2-empty-message');
    const comparisonContainer =
      domCache.comparisonContainer || document.getElementById('v2-comparison-container');

    if (!emptyMessage || !comparisonContainer) {
      // Required DOM elements not found for comparison arena
      return;
    }

    if (selectedCharacters.length === 0) {
      emptyMessage.style.display = 'block';
      comparisonContainer.classList.add('hidden');
    } else {
      emptyMessage.style.display = 'none';
      comparisonContainer.classList.remove('hidden');
      renderComparisonCards();
    }
  }

  /**
   * Render comparison cards with proper cleanup
   * @returns {void}
   */
  function renderComparisonCards() {
    const cardsGrid = domCache.cardsGrid || document.getElementById('v2-cards-grid');
    if (!cardsGrid) return;

    // Clean up existing event listeners first
    const existingCards = cardsGrid.querySelectorAll('.comparison-character-card');
    existingCards.forEach(card => {
      const cleanup = cardEventListeners.get(card);
      if (cleanup) {
        cleanup();
        cardEventListeners.delete(card);
      }
    });

    // Use DocumentFragment for better performance
    const fragment = document.createDocumentFragment();

    selectedCharacters.forEach(characterSlug => {
      const character = window.ZN_COMPARISON_V2_DATA.characters.find(c => c.slug === characterSlug);
      if (!character) return;

      const detailedData = characterDataMap.get(characterSlug);
      const cardElement = createCharacterCard(character, detailedData, characterSlug);
      fragment.appendChild(cardElement);
    });

    // Single DOM update
    cardsGrid.replaceChildren(fragment);
  }

  /**
   * Create a character card element using safe DOM methods
   * @param {Object} character - Character data
   * @param {Object} detailedData - Detailed character data
   * @param {string} characterSlug - Character slug for identification
   * @returns {HTMLElement} Card element
   */
  function createCharacterCard(character, detailedData, characterSlug) {
    const cardDiv = document.createElement('div');
    cardDiv.className = `comparison-character-card ${!detailedData ? 'loading' : ''}`;
    cardDiv.dataset.characterSlug = characterSlug;

    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.className = 'comparison-card-remove';
    removeBtn.setAttribute('title', 'Remove character');
    removeBtn.setAttribute('aria-label', `Remove ${character.originalName || character.name}`);
    removeBtn.textContent = 'Remove';

    // Create header section
    const header = document.createElement('div');
    header.className = 'comparison-card-header';

    const portrait = document.createElement('img');
    portrait.src = character.image || '/images/placeholder.png';
    portrait.alt = character.originalName || character.name || '';
    portrait.className = 'comparison-card-portrait';
    portrait.loading = 'lazy';
    portrait.onerror = function () {
      this.src = '/images/placeholder.png';
    };

    const info = document.createElement('div');
    info.className = 'comparison-card-info';

    const name = document.createElement('h3');
    name.textContent = character.originalName || character.name || '';

    const badges = document.createElement('div');
    badges.className = 'comparison-card-badges';

    // Create badges safely
    const badgeData = [
      { class: 'rarity-badge', value: character.rarity },
      { class: 'class-badge', value: character.class },
      { class: 'element-badge', value: character.element },
      { class: 'role-badge', value: character.role },
      { class: 'faction-badge', value: character.faction },
    ];

    badgeData.forEach(badge => {
      if (badge.value) {
        const span = document.createElement('span');
        span.className = `${badge.class} ${badge.value.toLowerCase().replace(/\s+/g, '-')}`;
        span.textContent = badge.value;
        badges.appendChild(span);
      }
    });

    // Assemble header
    info.appendChild(name);
    info.appendChild(badges);
    header.appendChild(portrait);
    header.appendChild(info);

    // Create stats section using SAFE DOM methods - FIX XSS VULNERABILITY
    const statsDiv = createCharacterStatsDOM(character, detailedData);

    // Assemble card
    cardDiv.appendChild(removeBtn);
    cardDiv.appendChild(header);
    cardDiv.appendChild(statsDiv);

    // Add event listener for remove button with cleanup tracking
    const removeHandler = () => removeCharacter(characterSlug);
    removeBtn.addEventListener('click', removeHandler);

    // Store cleanup function for this card
    cardEventListeners.set(cardDiv, () => {
      removeBtn.removeEventListener('click', removeHandler);
    });

    return cardDiv;
  }

  /**
   * Create character stats DOM safely to prevent XSS
   * @param {Object} character - Character data
   * @param {Object} detailedData - Detailed character data
   * @returns {HTMLElement} Stats container element
   */
  function createCharacterStatsDOM(character, detailedData) {
    const container = document.createElement('div');
    container.className = 'comparison-card-stats';

    const stats = character.stats || {};
    const lookupName = character.originalName || character.name;
    const tiers = getCharacterTiers(lookupName);
    const characterId = character.id;
    const rankings = getCharacterRankings(characterId);

    // Tier Rankings Section
    const tierSection = createStatSection('Tier Rankings', [
      {
        label: 'PvE',
        value: tiers.pve || 'Unranked',
        class: `tier-${(tiers.pve || '').toLowerCase()}`,
      },
      {
        label: 'PvP',
        value: tiers.pvp || 'Unranked',
        class: `tier-${(tiers.pvp || '').toLowerCase()}`,
      },
      {
        label: 'Rifts',
        value: tiers.rift || 'Unranked',
        class: `tier-${(tiers.rift || '').toLowerCase()}`,
      },
      {
        label: 'Guild Raids',
        value: tiers.guild || 'Unranked',
        class: `tier-${(tiers.guild || '').toLowerCase()}`,
      },
      {
        label: 'New Player',
        value: tiers.newPlayer || 'Unranked',
        class: `tier-${(tiers.newPlayer || '').toLowerCase()}`,
      },
    ]);

    // Stat Rankings Section
    const rankSection = createStatSection('Stat Rankings', [
      { label: 'Overall Rank', value: `#${getCompetitiveOverallRank(characterId, rankings)}` },
      { label: 'HP Rank', value: `#${formatRankValue(rankings.hp)}` },
      { label: 'ATK Rank', value: `#${formatRankValue(rankings.attack)}` },
      { label: 'DEF Rank', value: `#${formatRankValue(rankings.defense)}` },
    ]);

    // Combat Stats Section
    const combatSection = createStatSection('Combat Stats', [
      { label: 'HP', value: stats.hp ? stats.hp.toLocaleString() : 'N/A' },
      { label: 'ATK', value: stats.attack ? stats.attack.toLocaleString() : 'N/A' },
      { label: 'DEF', value: stats.defense ? stats.defense.toLocaleString() : 'N/A' },
      { label: 'Energy', value: stats.energyRecovery || '0' },
      { label: 'CRIT Rate', value: stats.critRate ? stats.critRate + '%' : '0%' },
      { label: 'CRIT DMG', value: stats.critDmg ? stats.critDmg + '%' : '0%' },
    ]);

    container.appendChild(tierSection);
    container.appendChild(rankSection);
    container.appendChild(combatSection);

    // Skills section
    if (detailedData) {
      const skillsSection = createSkillsSection(detailedData);
      container.appendChild(skillsSection);

      if (detailedData.teamSkill) {
        const teamSkillSection = createTeamSkillSection(detailedData.teamSkill);
        container.appendChild(teamSkillSection);
      }
    } else {
      const loadingSection = document.createElement('div');
      loadingSection.className = 'comparison-skills-section';
      const title = document.createElement('h4');
      title.textContent = 'Character Skills';
      const desc = document.createElement('div');
      desc.className = 'comparison-skill-desc';
      desc.textContent = 'Loading...';
      loadingSection.appendChild(title);
      loadingSection.appendChild(desc);
      container.appendChild(loadingSection);
    }

    return container;
  }

  /**
   * Create a stat section with safe DOM methods
   */
  function createStatSection(title, items) {
    const section = document.createElement('div');
    section.className = 'comparison-stat-section';

    const heading = document.createElement('h4');
    heading.textContent = title;
    section.appendChild(heading);

    const grid = document.createElement('div');
    grid.className = 'comparison-stat-grid';

    items.forEach(item => {
      const statItem = document.createElement('div');
      statItem.className = 'comparison-stat-item';

      const label = document.createElement('span');
      label.className = 'comparison-stat-label';
      label.textContent = item.label;

      const value = document.createElement('span');
      value.className = `comparison-stat-value ${item.class || ''}`;
      value.textContent = item.value;

      statItem.appendChild(label);
      statItem.appendChild(value);
      grid.appendChild(statItem);
    });

    section.appendChild(grid);
    return section;
  }

  /**
   * Create skills section with safe DOM methods
   */
  function createSkillsSection(detailedData) {
    const section = document.createElement('div');
    section.className = 'comparison-skills-section';

    const heading = document.createElement('h4');
    heading.textContent = 'Character Skills';
    section.appendChild(heading);

    const skills = ['normal', 'auto', 'ultimate', 'passive'];
    const skillTypes = {
      normal: 'Normal Attack',
      auto: 'Auto Skill',
      ultimate: 'Ultimate',
      passive: 'Passive',
    };

    skills.forEach(skillType => {
      const skill = detailedData.skills?.[skillType];
      if (!skill) return;

      const skillItem = document.createElement('div');
      skillItem.className = 'comparison-skill-item';

      const header = document.createElement('div');
      header.className = 'comparison-skill-header';

      const name = document.createElement('span');
      name.className = 'comparison-skill-name';
      name.textContent = skill.name || '';

      const badge = document.createElement('span');
      badge.className = `skill-badge ${skillType === 'normal' ? 'normal-attack' : skillType === 'auto' ? 'auto-skill' : skillType}`;
      badge.textContent = skillTypes[skillType];

      header.appendChild(name);
      header.appendChild(badge);
      skillItem.appendChild(header);

      const desc = document.createElement('div');
      desc.className = 'comparison-skill-desc';
      desc.textContent = skill.description || '';
      skillItem.appendChild(desc);

      if (skill.cooldown) {
        const cooldown = document.createElement('div');
        cooldown.className = 'comparison-skill-cooldown';
        cooldown.textContent = `Cooldown: ${skill.cooldown}`;
        skillItem.appendChild(cooldown);
      }

      if (skill.energyCost) {
        const energy = document.createElement('div');
        energy.className = 'comparison-skill-energy';
        energy.textContent = `Energy Cost: ${skill.energyCost}`;
        skillItem.appendChild(energy);
      }

      section.appendChild(skillItem);
    });

    if (section.children.length === 1) {
      const noData = document.createElement('div');
      noData.className = 'comparison-skill-desc';
      noData.textContent = 'No detailed skill data available';
      section.appendChild(noData);
    }

    return section;
  }

  /**
   * Create team skill section with safe DOM methods
   */
  function createTeamSkillSection(teamSkill) {
    const section = document.createElement('div');
    section.className = 'comparison-team-skill';

    const heading = document.createElement('h4');
    heading.textContent = 'Team Skill';
    section.appendChild(heading);

    const name = document.createElement('div');
    name.className = 'comparison-team-skill-name';
    name.textContent = teamSkill.name || '';
    section.appendChild(name);

    const desc = document.createElement('div');
    desc.className = 'comparison-team-skill-desc';
    desc.textContent = teamSkill.description || 'No team skill available';
    section.appendChild(desc);

    if (teamSkill.requirements) {
      const req = document.createElement('div');
      req.className = 'comparison-team-skill-req';
      req.textContent = `Requires: ${teamSkill.requirements.faction || ''} + ${teamSkill.requirements.element || ''}`;
      section.appendChild(req);
    }

    return section;
  }

  // Deprecated renderCharacterStats function removed - using createCharacterStatsDOM instead

  /**
   * Load character data using the centralized data component
   * @param {string} characterSlug - The character slug to load data for
   * @returns {void}
   */
  function loadCharacterData(characterSlug) {
    // Input validation
    if (!characterSlug || typeof characterSlug !== 'string') {
      // Invalid character slug provided to loadCharacterData
      return;
    }

    if (characterDataMap.has(characterSlug)) return;

    try {
      // Security: Validate against known character slugs to prevent path traversal
      const validSlugs = window.ZN_COMPARISON_V2_DATA?.characters?.map(char => char.slug) || [];
      if (!validSlugs.includes(characterSlug)) {
        throw new Error(`Invalid character slug: ${characterSlug}`);
      }

      // Get the character data from the global variable (passed from Astro)
      const characterData = window.ZN_COMPARISON_V2_DATA?.characterDataMap?.[characterSlug];

      if (characterData && typeof characterData === 'object') {
        characterDataMap.set(characterSlug, characterData);
      } else {
        // Set empty data if not found
        characterDataMap.set(characterSlug, {});
      }

      // Re-render the comparison cards to show loaded data
      renderComparisonCards();
    } catch (error) {
      console.error(`Could not load detailed data for character ${characterSlug}:`, error);
      // Set empty data to stop loading state
      characterDataMap.set(characterSlug, {});
      renderComparisonCards();
    }
  }

  /**
   * Update selected character count
   * @returns {void}
   */
  function updateSelectedCount() {
    const countElement = domCache.selectedCount || document.getElementById('v2-selected-count');
    if (countElement) {
      countElement.textContent = `${selectedCharacters.length}/${MAX_CHARACTERS} selected`;
    }
  }

  /**
   * Cleanup function to prevent memory leaks - call before page unload
   * @returns {void}
   */
  function cleanup() {
    // Clear search timeout
    clearTimeout(ZNComparisonV2.searchTimeout);

    // Abort any pending fetch operations
    ZNComparisonV2.activeAbortControllers.forEach(controller => {
      controller.abort();
    });
    ZNComparisonV2.activeAbortControllers.clear();

    // Clean up all tracked event listeners
    eventListeners.forEach(cleanupFn => {
      if (typeof cleanupFn === 'function') {
        cleanupFn();
      }
    });
    eventListeners.clear();

    // Clean up card event listeners
    const existingCards = document.querySelectorAll('.comparison-character-card');
    existingCards.forEach(card => {
      const cardCleanup = cardEventListeners.get(card);
      if (cardCleanup) {
        cardCleanup();
        cardEventListeners.delete(card);
      }
    });

    // Clear data maps
    characterDataMap.clear();
    selectedCharacters.length = 0;
    filteredCharacters.length = 0;

    // Reset DOM cache
    Object.keys(domCache).forEach(key => {
      if (key !== 'initialized') {
        domCache[key] = null;
      }
    });

    // Zone Nova Comparison V2: Cleanup completed
  }

  /**
   * Add keyboard navigation support
   * @returns {void}
   */
  function initializeKeyboardNavigation() {
    const keydownHandler = event => {
      // Handle Enter and Space for character icons
      if ((event.key === 'Enter' || event.key === ' ') && event.target.matches('.character-icon')) {
        event.preventDefault();
        event.target.click();
      }

      // Handle Escape to close modal
      if (event.key === 'Escape') {
        const modal = document.getElementById('v2-mobile-modal');
        if (modal && modal.classList.contains('open')) {
          ZNComparisonV2.closeMobileModal?.();
        }
      }
    };

    document.addEventListener('keydown', keydownHandler);
    eventListeners.set('keyboard-navigation', () => {
      document.removeEventListener('keydown', keydownHandler);
    });
  }

  // Add cleanup on page unload to prevent memory leaks
  const beforeUnloadHandler = cleanup;
  const pageHideHandler = cleanup;

  window.addEventListener('beforeunload', beforeUnloadHandler);
  window.addEventListener('pagehide', pageHideHandler);

  // Store cleanup handlers for potential removal
  eventListeners.set('page-unload', () => {
    window.removeEventListener('beforeunload', beforeUnloadHandler);
    window.removeEventListener('pagehide', pageHideHandler);
  });

  /**
   * Initialize modal control buttons (close only - simplified approach matching SAB)
   */
  function initializeModalControls(_modal) {
    const closeBtn = document.getElementById('v2-modal-close');
    const backdrop = document.getElementById('v2-modal-backdrop');

    if (closeBtn) {
      closeBtn.addEventListener('click', () => ZNComparisonV2.closeMobileModal?.());
    }

    if (backdrop) {
      backdrop.addEventListener('click', () => ZNComparisonV2.closeMobileModal?.());
    }

    // Escape key handling is already done in initializeKeyboardNavigation
  }

  /**
   * Initialize modal search functionality
   */
  function initializeModalSearch() {
    const searchInput = document.getElementById('v2-modal-search');
    if (!searchInput) return;

    const searchHandler = e => {
      clearTimeout(ZNComparisonV2.searchTimeout);
      ZNComparisonV2.searchTimeout = setTimeout(() => {
        updateModalCharacterGrid(e.target.value);
      }, SEARCH_DEBOUNCE_MS);
    };

    // Track for cleanup
    searchInput.addEventListener('input', searchHandler);
    eventListeners.set('modal-search', () => {
      searchInput.removeEventListener('input', searchHandler);
    });
  }

  /**
   * Initialize modal filter functionality (placeholder for consistency with SAB)
   */
  function initializeModalFilters() {
    // Modal filters removed for mobile optimization - placeholder for consistency
  }

  /**
   * Initialize modal character grid interactions
   */
  function initializeModalCharacterGrid() {
    const characterGrid = document.getElementById('v2-modal-character-grid');
    if (!characterGrid) return;

    const characterGridHandler = event => {
      const characterCard = event.target.closest('.modal-character-card');
      if (!characterCard) return;

      const characterSlug = characterCard.dataset.characterSlug;
      const currentSlot = ZNComparisonV2.getCurrentMobileSlot?.();

      if (characterSlug && currentSlot) {
        // Set character for the current slot
        if (currentSlot === 1) {
          selectedCharacters[0] = characterSlug;
        } else if (currentSlot === 2) {
          selectedCharacters[1] = characterSlug;
        }

        // Update displays
        updateAllDisplays();
        // Load character data
        loadCharacterData(characterSlug);

        // Close modal
        ZNComparisonV2.closeMobileModal?.();

        // Auto-scroll to comparison section when 2 characters are selected (mobile/tablet)
        if (selectedCharacters.filter(Boolean).length === MAX_CHARACTERS) {
          setTimeout(() => {
            const comparisonContainer = document.getElementById('v2-comparison-container');
            if (comparisonContainer && !comparisonContainer.classList.contains('hidden')) {
              comparisonContainer.scrollIntoView({
                behavior: 'smooth',
                block: 'start',
                inline: 'nearest',
              });
            }
          }, 300); // Slightly longer delay for mobile to ensure modal is closed
        }
      }
    };

    // Add the handler with proper cleanup tracking
    characterGrid.addEventListener('click', characterGridHandler);
    eventListeners.set('modal-grid', () => {
      characterGrid.removeEventListener('click', characterGridHandler);
    });
  }

  /**
   * Update modal character grid based on search and filters
   */
  function updateModalCharacterGrid(searchTerm = '') {
    const characterGrid = document.getElementById('v2-modal-character-grid');
    if (!characterGrid) return;

    const cards = characterGrid.querySelectorAll('.modal-character-card');
    const searchTermLower = searchTerm.toLowerCase();

    cards.forEach(card => {
      const characterName = card.querySelector('.modal-character-name').textContent.toLowerCase();
      const characterSlug = card.dataset.characterSlug || '';

      const matchesSearch =
        !searchTerm ||
        characterName.includes(searchTermLower) ||
        characterSlug.toLowerCase().includes(searchTermLower);

      if (matchesSearch) {
        card.classList.remove('filtered-out');
      } else {
        card.classList.add('filtered-out');
      }
    });
  }

  /**
   * Update modal character selection states
   */
  function updateModalCharacterStates() {
    const characterGrid = document.getElementById('v2-modal-character-grid');
    if (!characterGrid) return;

    const cards = characterGrid.querySelectorAll('.modal-character-card');

    cards.forEach(card => {
      const characterSlug = card.dataset.characterSlug;
      const isSelected = selectedCharacters.includes(characterSlug);

      if (isSelected) {
        card.classList.add('selected');
      } else {
        card.classList.remove('selected');
      }
    });
  }

  /**
   * Update mobile selection buttons to show current character selections
   */
  function updateMobileSelectionButtons() {
    [1, 2].forEach(slotNumber => {
      const characterSlug = selectedCharacters[slotNumber - 1];
      const character = characterSlug
        ? window.ZN_COMPARISON_V2_DATA.characters.find(c => c.slug === characterSlug)
        : null;
      updateSelectionButtonDisplay(slotNumber, character);
    });
  }

  /**
   * Update the display of a selection button using safe DOM methods
   */
  function updateSelectionButtonDisplay(slotNumber, character) {
    const buttonContent = document.getElementById(`v2-mobile-display-${slotNumber}`);
    if (!buttonContent) return;

    // Clear existing content
    buttonContent.textContent = '';

    if (character) {
      // Create selected character display
      const selectedDisplay = document.createElement('div');
      selectedDisplay.className = 'selected-character-display';

      const img = document.createElement('img');
      img.src = character.image || '/images/placeholder.png';
      img.alt = character.originalName || character.name || '';
      img.className = 'selected-character-image';
      img.onerror = function () {
        this.src = '/images/placeholder.png';
      };

      const info = document.createElement('div');
      info.className = 'selected-character-info';

      const name = document.createElement('span');
      name.className = 'selected-character-name';
      name.textContent = character.originalName || character.name || '';

      const details = document.createElement('span');
      details.className = 'selected-character-details';
      details.textContent = `${character.rarity || ''} ${character.element || ''}`;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'selection-remove-btn';
      removeBtn.textContent = '×';
      removeBtn.title = 'Remove character';
      removeBtn.addEventListener('click', event => {
        event.stopPropagation();
        // Remove character properly
        const characterSlug = selectedCharacters[slotNumber - 1];
        if (characterSlug) {
          const index = selectedCharacters.indexOf(characterSlug);
          if (index > -1) {
            selectedCharacters.splice(index, 1);
          }
        }
        // Update displays
        updateAllDisplays();
      });

      info.appendChild(name);
      info.appendChild(details);
      selectedDisplay.appendChild(img);
      selectedDisplay.appendChild(info);
      selectedDisplay.appendChild(removeBtn);
      buttonContent.appendChild(selectedDisplay);
    } else {
      // Create placeholder display
      const placeholder = document.createElement('div');
      placeholder.className = 'selection-placeholder';

      const icon = document.createElement('span');
      icon.className = 'selection-icon';
      icon.textContent = '+';

      const text = document.createElement('span');
      text.className = 'selection-text';
      text.textContent = `Select Character ${slotNumber}`;

      placeholder.appendChild(icon);
      placeholder.appendChild(text);
      buttonContent.appendChild(placeholder);
    }
  }

  /**
   * Centralized update function to batch DOM updates
   */
  function updateAllDisplays() {
    requestAnimationFrame(() => {
      updateIconStates();
      updateMobileSelectionButtons();
      updateComparisonContainer();
      updateSelectedCount();
    });
  }

  // Export only essential functions to global scope
  window.ZN_COMPARISON_V2_CLEANUP = cleanup; // Export cleanup for manual cleanup
</script>
