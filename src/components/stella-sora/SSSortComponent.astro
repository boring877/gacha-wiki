---
// Stella Sora Sorting Component
// Provides sorting controls for character database
---

<div class="ss-sort-component">
  <div class="sort-section">
    <h3 class="sort-title">Sort By</h3>
    <div class="sort-controls">
      <button class="sort-btn" data-sort="rarity">
        Rarity
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="name">
        Name
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="hp">
        HP
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="attack">
        ATK
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="defense">
        DEF
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="critRate">
        Crit%
        <span class="sort-arrow"></span>
      </button>

      <button class="sort-btn" data-sort="critDmg">
        Crit DMG
        <span class="sort-arrow"></span>
      </button>
    </div>
  </div>
</div>

<script>
  // --- Sort Component State ---
  let currentSortKey: string | null = null;
  let currentSortDirection = 'normal';
  let originalRows: HTMLElement[] = [];
  let originalCards: HTMLElement[] = [];

  // DOM references
  let tableBody, mobileCardsContainer;

  function initializeSorting() {
    // Get DOM references
    tableBody = document.getElementById('character-table-body');
    mobileCardsContainer = document.getElementById('character-cards');

    // Early exit if required elements don't exist
    if (!tableBody || !mobileCardsContainer) {
      console.error('Required elements not found:', {
        tableBody: !!tableBody,
        mobileCardsContainer: !!mobileCardsContainer,
      });
      return;
    }

    // Store original rows and cards for sorting
    try {
      originalRows = Array.from(tableBody.querySelectorAll('.character-row'));
      originalCards = Array.from(mobileCardsContainer.querySelectorAll('.character-card'));
    } catch (error) {
      console.error('Error storing original rows and cards:', error);
      return;
    }

    // Validate that we found elements to sort
    if (originalRows.length === 0) {
      console.warn('No character rows found for sorting');
    }
    if (originalCards.length === 0) {
      console.warn('No character cards found for sorting');
    }

    // Restore saved state
    restoreState();

    // Setup event listeners
    setupEventListeners();

    // Listen for filter events from filter component
    document.addEventListener('filtersApplied', handleFiltersApplied);
    document.addEventListener('filtersReset', handleFiltersReset);
  }

  function setupEventListeners() {
    // Sort buttons
    const sortButtons = document.querySelectorAll('.sort-btn');

    if (sortButtons.length === 0) {
      console.warn('No sort buttons found');
      return;
    }

    sortButtons.forEach(button => {
      const sortKey = (button as HTMLElement).dataset.sort;
      if (!sortKey) {
        console.warn('Sort button missing data-sort attribute:', button);
        return;
      }

      button.addEventListener('click', function () {
        cycleSortState(this);
      });
    });

    // Add navigation listeners to character links (if they exist)
    const characterLinks = document.querySelectorAll('.character-link');
    if (characterLinks.length > 0) {
      characterLinks.forEach(link => {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const characterSlug = (this as HTMLElement).dataset.slug;
          if (characterSlug) {
            window.location.href = `/guides/stella-sora/characters/${characterSlug}`;
          }
        });
      });
    }
  }

  function cycleSortState(sortButton: HTMLElement) {
    const sortKey = sortButton.dataset.sort;

    if (currentSortKey !== sortKey) {
      // New sort field selected
      currentSortKey = sortKey || null;
      currentSortDirection = 'desc'; // Start with desc (down arrow) first - highest first
    } else {
      // Same field selected, cycle through states
      if (currentSortDirection === 'normal') {
        currentSortDirection = 'desc'; // Start with desc (down arrow) - highest first
      } else if (currentSortDirection === 'desc') {
        currentSortDirection = 'asc'; // Then asc (up arrow) - lowest first
      } else {
        currentSortDirection = 'normal'; // Then back to normal
        currentSortKey = null;
      }
    }

    // Update button visual states
    updateSortButtons();

    // Apply sorting if we have a sort key
    if (currentSortKey) {
      applySort(currentSortKey);
    } else {
      // Reset to original order
      resetToOriginalOrder();
    }

    // Save sort state
    saveSortState();
  }

  function updateSortButtons() {
    // Clear all sort states
    const sortButtons = document.querySelectorAll('.sort-btn');
    if (sortButtons.length === 0) {
      console.warn('No sort buttons found to update');
      return;
    }

    sortButtons.forEach(button => {
      button.classList.remove('active');
      const arrow = button.querySelector('.sort-arrow');
      if (arrow) {
        arrow.textContent = '';
      }
    });

    // Set current sort button state
    if (currentSortKey && currentSortDirection !== 'normal') {
      const currentButton = document.querySelector(`[data-sort="${currentSortKey}"]`);
      if (currentButton) {
        currentButton.classList.add('active');
        const arrow = currentButton.querySelector('.sort-arrow');
        if (arrow) {
          arrow.textContent = currentSortDirection === 'asc' ? ' ↓' : ' ↑';
        }
      } else {
        console.warn(`Sort button with key "${currentSortKey}" not found`);
      }
    }
  }

  function applySort(sortKey) {
    // Early return if we don't have data to sort
    if (
      !originalRows ||
      !originalCards ||
      originalRows.length === 0 ||
      originalCards.length === 0
    ) {
      console.warn('No data available for sorting');
      return;
    }

    // Get all visible rows and cards (not filtered out)
    const visibleRows = originalRows.filter(
      row => row && row.style && row.style.display !== 'none'
    );
    const visibleCards = originalCards.filter(
      (card, index) =>
        originalRows[index] &&
        originalRows[index].style &&
        originalRows[index].style.display !== 'none'
    );

    // Sort rows based on the sort key
    const sortedRows = visibleRows.sort((a, b) => {
      // Safety checks for elements
      if (!a || !b) return 0;

      let valueA, valueB;

      switch (sortKey) {
        case 'rarity':
          const rarityOrder = { '5-Star': 0, '4-Star': 1, '3-Star': 2 };
          const rarityA = a.dataset.rarity || '';
          const rarityB = b.dataset.rarity || '';
          valueA = rarityOrder[rarityA] ?? 99;
          valueB = rarityOrder[rarityB] ?? 99;
          // For rarity: desc = highest first (5-Star), asc = lowest first (3-Star)
          return currentSortDirection === 'asc' ? valueB - valueA : valueA - valueB;

        case 'name':
          const nameElementA = a.querySelector('.character-name');
          const nameElementB = b.querySelector('.character-name');
          valueA = nameElementA?.textContent || '';
          valueB = nameElementB?.textContent || '';
          return currentSortDirection === 'asc'
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);

        case 'hp':
        case 'attack':
        case 'defense':
        case 'critRate':
        case 'critDmg':
          // Look for data attributes on the cells, not the row
          const cellA = a.querySelector(`[data-${sortKey}]`) as HTMLElement;
          const cellB = b.querySelector(`[data-${sortKey}]`) as HTMLElement;

          valueA = 0;
          valueB = 0;

          // Safely extract and parse values from data attributes
          if (cellA && cellA.dataset && cellA.dataset[sortKey]) {
            const parsedValue = parseFloat(cellA.dataset[sortKey]);
            valueA = isNaN(parsedValue) ? 0 : parsedValue;
          }

          if (cellB && cellB.dataset && cellB.dataset[sortKey]) {
            const parsedValue = parseFloat(cellB.dataset[sortKey]);
            valueB = isNaN(parsedValue) ? 0 : parsedValue;
          }

          return currentSortDirection === 'asc' ? valueA - valueB : valueB - valueA;

        default:
          return 0;
      }
    });

    // Sort cards to match rows
    const sortedCards = sortedRows
      .map(row => {
        const rowIndex = originalRows.indexOf(row);
        return originalCards[rowIndex];
      })
      .filter(Boolean);

    // Re-append sorted content
    if (tableBody) {
      tableBody.innerHTML = '';
      sortedRows.forEach(row => tableBody.appendChild(row));
      if (typeof (window as any).renumberRows === 'function') {
        (window as any).renumberRows();
      }
    }
    if (mobileCardsContainer) {
      mobileCardsContainer.innerHTML = '';
      sortedCards.forEach(card => mobileCardsContainer.appendChild(card));
    }
  }

  function resetToOriginalOrder() {
    // Early return if we don't have data to sort
    if (
      !originalRows ||
      !originalCards ||
      originalRows.length === 0 ||
      originalCards.length === 0
    ) {
      console.warn('No data available for reset to original order');
      return;
    }

    // Get all visible rows and cards
    const visibleRows = originalRows.filter(
      row => row && row.style && row.style.display !== 'none'
    );
    const visibleCards = originalCards.filter(
      (card, index) =>
        originalRows[index] &&
        originalRows[index].style &&
        originalRows[index].style.display !== 'none'
    );

    // Sort by rarity (default order) - 5-Star first
    const rarityOrder = { '5-Star': 0, '4-Star': 1, '3-Star': 2 };
    const sortedRows = visibleRows.sort((a, b) => {
      // Safety checks for elements
      if (!a || !b) return 0;

      const rarityA = a.dataset.rarity || '';
      const rarityB = b.dataset.rarity || '';
      return (rarityOrder[rarityA] ?? 99) - (rarityOrder[rarityB] ?? 99);
    });

    const sortedCards = sortedRows
      .map(row => {
        const rowIndex = originalRows.indexOf(row);
        return originalCards[rowIndex];
      })
      .filter(Boolean);

    // Re-append sorted content
    if (tableBody) {
      tableBody.innerHTML = '';
      sortedRows.forEach((row, index) => {
        const numberCell = row.querySelector('td:first-child');
        if (numberCell) numberCell.textContent = String(index + 1);
        tableBody.appendChild(row);
      });
    }
    if (mobileCardsContainer) {
      mobileCardsContainer.innerHTML = '';
      sortedCards.forEach(card => mobileCardsContainer.appendChild(card));
    }
  }

  function handleFiltersApplied(event) {
    // Re-apply current sort when filters change
    if (currentSortKey && currentSortDirection !== 'normal') {
      applySort(currentSortKey);
    } else {
      if (typeof (window as any).renumberRows === 'function') {
        (window as any).renumberRows();
      }
    }
  }

  function handleFiltersReset() {
    // Reset sort state when filters are reset
    currentSortKey = null;
    currentSortDirection = 'normal';
    updateSortButtons();

    // Clear sort session storage
    try {
      sessionStorage.removeItem('ss-character-sort-v2');
    } catch (_error) {
      // Ignore storage errors
    }

    // Re-sort by rarity (default order) - 5-Star first
    const rarityOrder = { '5-Star': 0, '4-Star': 1, '3-Star': 2 };

    // Get all rows and cards
    const allRows = [...originalRows];
    const allCards = [...originalCards];

    // Sort by rarity
    const sortedIndices = allRows
      .map((row, index) => ({ row, index, rarity: row?.dataset?.rarity || '' }))
      .sort((a, b) => (rarityOrder[a.rarity] ?? 99) - (rarityOrder[b.rarity] ?? 99))
      .map(item => item.index);

    // Re-append in sorted order
    if (tableBody) {
      tableBody.innerHTML = '';
      sortedIndices.forEach((originalIndex, newIndex) => {
        const row = allRows[originalIndex];
        if (row) {
          row.style.display = '';
          const numberCell = row.querySelector('td:first-child');
          if (numberCell) numberCell.textContent = String(newIndex + 1);
          tableBody.appendChild(row);
        }
      });
    }

    if (mobileCardsContainer) {
      mobileCardsContainer.innerHTML = '';
      sortedIndices.forEach((originalIndex) => {
        const card = allCards[originalIndex];
        if (card) {
          card.style.display = '';
          mobileCardsContainer.appendChild(card);
        }
      });
    }
  }

  function saveSortState() {
    try {
      sessionStorage.setItem(
        'ss-character-sort-v2',
        JSON.stringify({
          key: currentSortKey,
          direction: currentSortDirection,
        })
      );
    } catch (_error) {
      // Ignore storage errors
    }
  }

  function restoreState() {
    // Restore sort state
    try {
      const savedSort = sessionStorage.getItem('ss-character-sort-v2');
      if (savedSort) {
        const sortState = JSON.parse(savedSort);
        // Only restore if we have valid saved state
        if (sortState.key && sortState.direction) {
          currentSortKey = sortState.key;
          currentSortDirection = sortState.direction;
          applySort(currentSortKey);
        } else {
          // Clear invalid session storage
          sessionStorage.removeItem('ss-character-sort-v2');
        }
      }
    } catch (_error) {
      // Clear corrupted session storage
      try {
        sessionStorage.removeItem('ss-character-sort-v2');
      } catch (_cleanupError) {
        // Ignore cleanup errors
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSorting);
  } else {
    initializeSorting();
  }
</script>
