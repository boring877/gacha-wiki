---
import { characters } from '../../data/silver-and-blood/characters.js';
import MobileCharacterNavigation from './MobileCharacterNavigation.astro';

export interface Props {
  currentCharacterSlug: string;
}

const { currentCharacterSlug } = Astro.props;

// Note: Client-side navigation will handle filter/sort state from sessionStorage
// This server-side rendering uses default database order as fallback
const charactersByDatabaseOrder = [...characters].sort((a, b) => a.name.localeCompare(b.name));

// Find current character index in database order
const currentIndex = charactersByDatabaseOrder.findIndex(
  char => char.slug === currentCharacterSlug
);

// Get previous and next characters (with wraparound)
const prevIndex = currentIndex > 0 ? currentIndex - 1 : charactersByDatabaseOrder.length - 1;
const nextIndex = currentIndex < charactersByDatabaseOrder.length - 1 ? currentIndex + 1 : 0;

const prevCharacter = charactersByDatabaseOrder[prevIndex];
const nextCharacter = charactersByDatabaseOrder[nextIndex];

// Only render if we have valid navigation targets
const hasNavigation = currentIndex !== -1 && prevCharacter && nextCharacter;

// Always render if we have characters, even if navigation logic fails
const forceRender = charactersByDatabaseOrder.length > 0;
---

<style>
  @import '../../styles/components/silver-and-blood-character-navigation.css';
</style>

{
  (hasNavigation || forceRender) && prevCharacter && nextCharacter && (
    <>
      {/* Desktop Navigation Panel */}
      <div
        class="nav-zone nav-zone-single"
        data-character-url={nextCharacter.detailUrl}
        data-character-name={nextCharacter.name}
        title="Character Navigation"
      >
        <div class="nav-controls">
          <button
            class="nav-btn nav-btn-prev"
            data-direction="prev"
            title={`Previous: ${prevCharacter.name}`}
          >
            ‹
          </button>
          <button
            class="nav-btn nav-btn-next"
            data-direction="next"
            title={`Next: ${nextCharacter.name}`}
          >
            ›
          </button>
        </div>
        <div class="nav-info">
          <div class="nav-current-character">
            <div class="nav-character-name">Current Character</div>
            <div class="nav-character-details">
              <span class="nav-position">0/0</span>
              <span class="nav-total-filtered">0 characters</span>
            </div>
          </div>
          <div class="nav-navigation-info">
            <div class="nav-next-character">
              <span class="nav-label">Next:</span>
              <span class="nav-next-name">{nextCharacter.name}</span>
            </div>
            <div class="nav-sort-info">
              <span class="nav-label">Sort:</span>
              <span class="nav-sort">Default</span>
            </div>
            <div class="nav-filter-info">
              <span class="nav-label">Filter:</span>
              <span class="nav-filter">None</span>
            </div>
          </div>
        </div>
      </div>

      {/* Mobile Navigation Component */}
      <MobileCharacterNavigation prevCharacter={prevCharacter} nextCharacter={nextCharacter} />
    </>
  )
}

<script>
  // Import character data and utilities
  import { characters } from '../../data/silver-and-blood/characters.js';

  // Character navigation functionality with performance optimizations
  document.addEventListener('DOMContentLoaded', () => {
    // Cache DOM elements for better performance
    const elements = {
      navPanel: document.querySelector('.nav-zone-single') as HTMLElement | null,
      prevButton: document.querySelector('.nav-btn-prev') as HTMLButtonElement | null,
      nextButton: document.querySelector('.nav-btn-next') as HTMLButtonElement | null,
      // Cache navigation info elements
      currentNameEl: null as HTMLElement | null,
      positionEl: null as HTMLElement | null,
      totalFilteredEl: null as HTMLElement | null,
      nextNameEl: null as HTMLElement | null,
      sortEl: null as HTMLElement | null,
      filterEl: null as HTMLElement | null,
    };

    // Initialize cached elements
    if (elements.navPanel) {
      elements.currentNameEl = elements.navPanel.querySelector(
        '.nav-character-name'
      ) as HTMLElement | null;
      elements.positionEl = elements.navPanel.querySelector('.nav-position') as HTMLElement | null;
      elements.totalFilteredEl = elements.navPanel.querySelector(
        '.nav-total-filtered'
      ) as HTMLElement | null;
      elements.nextNameEl = elements.navPanel.querySelector('.nav-next-name') as HTMLElement | null;
      elements.sortEl = elements.navPanel.querySelector('.nav-sort') as HTMLElement | null;
      elements.filterEl = elements.navPanel.querySelector('.nav-filter') as HTMLElement | null;
    }

    // Get current character slug from the page URL
    const currentCharacterSlug = window.location.pathname.split('/').pop() || '';

    // Performance optimization manager with proper types
    const perfManager: {
      sessionCache: { filters: FilterState; sort: SortState } | null;
      sessionCacheTime: number;
      characterListCache: Character[] | null;
      characterListCacheKey: string;
      CACHE_DURATION: number;
    } = {
      sessionCache: null,
      sessionCacheTime: 0,
      characterListCache: null,
      characterListCacheKey: '',
      CACHE_DURATION: 5000, // 5 second cache for better performance
    };

    // High-performance session storage access
    function getCachedSessionData() {
      const now = Date.now();
      if (
        perfManager.sessionCache &&
        now - perfManager.sessionCacheTime < perfManager.CACHE_DURATION
      ) {
        return perfManager.sessionCache;
      }

      try {
        const filterState = sessionStorage.getItem('sab-character-filters');
        const sortState = sessionStorage.getItem('sab-character-sort');

        perfManager.sessionCache = {
          filters: filterState ? JSON.parse(filterState) : {},
          sort: sortState ? JSON.parse(sortState) : { column: 'name', asc: true },
        };
        perfManager.sessionCacheTime = now;

        return perfManager.sessionCache;
      } catch (error: unknown) {
        perfManager.sessionCache = {
          filters: {},
          sort: { column: 'name', asc: true },
        };
        return perfManager.sessionCache;
      }
    }

    // Type definitions for better type safety
    type Character = (typeof characters)[0];
    type FilterState = Record<string, string | undefined>;
    type SortState = { column: string; asc: boolean };

    // Optimized character filtering
    function applyFilters(characters: Character[], filters: FilterState) {
      if (!filters || Object.keys(filters).length === 0) return characters;

      return characters.filter(character => {
        return (
          (!filters.class || character.class === filters.class) &&
          (!filters.rarity || character.rarity === filters.rarity) &&
          (!filters.faction || character.faction === filters.faction) &&
          (!filters.moonPhase || character.moonPhase === filters.moonPhase) &&
          (!filters.equipmentType || character.equipmentType === filters.equipmentType)
        );
      });
    }

    // Optimized character sorting
    function applySorting(characters: Character[], sort: SortState) {
      if (sort.column === 'name') {
        return characters.sort((a, b) => {
          const result = a.name.localeCompare(b.name);
          return sort.asc ? result : -result;
        });
      }

      if (sort.column === 'id') {
        return characters.sort((a, b) => {
          const result = a.name.localeCompare(b.name);
          return sort.asc ? result : -result;
        });
      }

      // For stat columns
      return characters.sort((a, b) => {
        const valA = a.stats?.[sort.column] ?? a[sort.column] ?? 0;
        const valB = b.stats?.[sort.column] ?? b[sort.column] ?? 0;

        const numA = Number(valA);
        const numB = Number(valB);

        if (!isNaN(numA) && !isNaN(numB)) {
          return sort.asc ? numA - numB : numB - numA;
        }

        const strA = String(valA).toLowerCase();
        const strB = String(valB).toLowerCase();
        return sort.asc ? strA.localeCompare(strB) : strB.localeCompare(strA);
      });
    }

    // Optimized character list processing with caching
    function getCurrentCharacterList() {
      const { filters, sort } = getCachedSessionData();
      const cacheKey = `${JSON.stringify(filters)}_${JSON.stringify(sort)}`;

      // Return cached result if available
      if (perfManager.characterListCacheKey === cacheKey && perfManager.characterListCache) {
        return perfManager.characterListCache;
      }

      // Process and cache characters
      const filtered = applyFilters(characters, filters);
      const sorted = applySorting(filtered, sort);

      perfManager.characterListCache = sorted;
      perfManager.characterListCacheKey = cacheKey;

      return sorted;
    }

    // Sort display names lookup
    const SORT_NAMES = {
      name: 'Name',
      id: 'Default',
      hp: 'HP',
      atk: 'ATK',
      pDef: 'P.DEF',
      mDef: 'M.DEF',
      critRate: 'Crit Rate',
      critDmgIncrease: 'Crit DMG',
      bloodsoulRecovery: 'Bloodsoul',
    } as const;

    function getSortDisplayName(sortColumn: string) {
      return SORT_NAMES[sortColumn] || sortColumn;
    }

    // Numeric columns for sort direction
    const NUMERIC_COLUMNS = [
      'hp',
      'atk',
      'pDef',
      'mDef',
      'critRate',
      'critDmgIncrease',
      'bloodsoulRecovery',
    ];

    // Optimized display info generation
    function getDisplayInfo() {
      const { filters, sort } = getCachedSessionData();

      // Calculate sort info
      let sortInfo = 'Default';
      if (sort.column !== 'name' || !sort.asc) {
        const direction = NUMERIC_COLUMNS.includes(sort.column)
          ? sort.asc
            ? '↓'
            : '↑'
          : sort.asc
            ? '↑'
            : '↓';
        sortInfo = `${getSortDisplayName(sort.column)} ${direction}`;
      }

      // Calculate filter info
      const activeFilters = Object.values(filters).filter(Boolean);
      const filterInfo = activeFilters.length > 0 ? activeFilters.join(', ') : 'None';

      return { sortInfo, filterInfo };
    }

    // Optimized function to update navigation panel
    function updateNavigationPanel() {
      if (!elements.navPanel) return;

      const characterList = getCurrentCharacterList();
      const currentIndex = characterList.findIndex(char => char.slug === currentCharacterSlug);

      if (currentIndex === -1) {
        elements.navPanel.style.display = 'none';
        return;
      }

      elements.navPanel.style.display = '';

      // Calculate navigation indices with wraparound
      const totalChars = characterList.length;
      const prevIndex = currentIndex > 0 ? currentIndex - 1 : totalChars - 1;
      const nextIndex = currentIndex < totalChars - 1 ? currentIndex + 1 : 0;

      const currentCharacter = characterList[currentIndex];
      const prevCharacter = characterList[prevIndex];
      const nextCharacter = characterList[nextIndex];

      const { sortInfo, filterInfo } = getDisplayInfo();

      // Batch DOM updates for better performance
      const updates = [
        [elements.currentNameEl, currentCharacter.name],
        [elements.positionEl, `${currentIndex + 1}/${totalChars}`],
        [elements.totalFilteredEl, `${totalChars} character${totalChars !== 1 ? 's' : ''}`],
        [elements.nextNameEl, nextCharacter.name],
        [elements.sortEl, sortInfo],
        [elements.filterEl, filterInfo],
      ] as const;

      // Apply text updates efficiently
      for (const [element, text] of updates) {
        if (element && element.textContent !== text) {
          element.textContent = text;
        }
      }

      // Update navigation attributes efficiently
      if (elements.prevButton) {
        const currentUrl = elements.prevButton.getAttribute('data-character-url');
        if (currentUrl !== prevCharacter.detailUrl) {
          elements.prevButton.setAttribute('data-character-url', prevCharacter.detailUrl);
          elements.prevButton.setAttribute('title', `Previous: ${prevCharacter.name}`);
        }
      }

      if (elements.nextButton) {
        const currentUrl = elements.nextButton.getAttribute('data-character-url');
        if (currentUrl !== nextCharacter.detailUrl) {
          elements.nextButton.setAttribute('data-character-url', nextCharacter.detailUrl);
          elements.nextButton.setAttribute('title', `Next: ${nextCharacter.name}`);
        }
      }

      // Update mobile navigation via the mobile component
      if (typeof (window as any).updateMobileNavigation === 'function') {
        (window as any).updateMobileNavigation(prevCharacter, nextCharacter);
      }
    }

    // Initialize navigation on page load
    updateNavigationPanel();

    // Debounced update function for better performance
    let updateTimeout: ReturnType<typeof setTimeout> | null = null;
    function debouncedUpdate() {
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      updateTimeout = setTimeout(() => {
        // Clear caches when data changes
        perfManager.sessionCache = null;
        perfManager.characterListCache = null;
        perfManager.characterListCacheKey = '';
        updateNavigationPanel();
      }, 100); // 100ms debounce
    }

    // Update navigation when sessionStorage changes (for cross-tab synchronization)
    window.addEventListener('storage', e => {
      if (e.key === 'sab-character-filters' || e.key === 'sab-character-sort') {
        debouncedUpdate();
      }
    });

    // Also listen for custom events from the character database when sorting/filtering changes
    document.addEventListener('character-database-updated', () => {
      debouncedUpdate();
    });

    // Instant navigation with pre-loading and fade effect
    function handleNavigation(url: string | null) {
      if (!url || typeof url !== 'string') {
        return false;
      }

      try {
        // Add loading state immediately for instant feedback
        document.body.style.opacity = '0.8';
        document.body.style.transition = 'opacity 0.1s ease';

        // For faster perception, use location.replace to avoid back button issues
        window.location.replace(url);
        return true;
      } catch (error: unknown) {
        // Reset opacity on error
        document.body.style.opacity = '1';
        return false;
      }
    }

    // Prefetch function for instant loading
    function prefetchPage(url: string | null) {
      if (!url) return;

      const existing = document.querySelector(`link[href="${url}"]`);
      if (existing) return;

      const link = document.createElement('link');
      link.rel = 'prefetch';
      link.href = url;
      document.head.appendChild(link);
    }

    // Navigation button handlers with instant prefetching
    if (elements.prevButton) {
      // Prefetch on hover for instant loading
      elements.prevButton.addEventListener('mouseenter', () => {
        const url = elements.prevButton?.getAttribute('data-character-url') || null;
        prefetchPage(url);
      });

      elements.prevButton.addEventListener('click', e => {
        e.preventDefault();
        const url = elements.prevButton?.getAttribute('data-character-url') || null;
        handleNavigation(url);
      });
    }

    if (elements.nextButton) {
      // Prefetch on hover for instant loading
      elements.nextButton.addEventListener('mouseenter', () => {
        const url = elements.nextButton?.getAttribute('data-character-url') || null;
        prefetchPage(url);
      });

      elements.nextButton.addEventListener('click', e => {
        e.preventDefault();
        const url = elements.nextButton?.getAttribute('data-character-url') || null;
        handleNavigation(url);
      });
    }

    // Keyboard navigation support with validation
    document.addEventListener('keydown', e => {
      // Don't interfere with form inputs or when modifier keys are pressed
      const target = e.target as HTMLElement;
      if (
        target?.tagName === 'INPUT' ||
        target?.tagName === 'TEXTAREA' ||
        e.ctrlKey ||
        e.altKey ||
        e.metaKey
      ) {
        return;
      }

      try {
        if (e.key === 'ArrowLeft' && elements.prevButton) {
          e.preventDefault();
          // Prefetch immediately on keydown for instant loading
          const url = elements.prevButton?.getAttribute('data-character-url') || null;
          prefetchPage(url);
          handleNavigation(url);
        } else if (e.key === 'ArrowRight' && elements.nextButton) {
          e.preventDefault();
          // Prefetch immediately on keydown for instant loading
          const url = elements.nextButton?.getAttribute('data-character-url') || null;
          prefetchPage(url);
          handleNavigation(url);
        }
      } catch (error: unknown) {
        // console.error('Keyboard navigation error:', error);
      }
    });

    // Cleanup function to prevent memory leaks
    function cleanup() {
      // Clear all caches
      perfManager.sessionCache = null;
      perfManager.characterListCache = null;
      perfManager.characterListCacheKey = '';

      // Clear timeout
      if (updateTimeout) {
        clearTimeout(updateTimeout);
        updateTimeout = null;
      }
    }

    // Register cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        // Page is being hidden, clean up caches to free memory
        perfManager.characterListCache = null;
        perfManager.characterListCacheKey = '';
      }
    });
  });
</script>
