---
export interface Props {
  currentCharacterSlug: string;
  prevCharacter: {
    slug: string;
    name: string;
  } | null;
  nextCharacter: {
    slug: string;
    name: string;
  } | null;
}

const { prevCharacter, nextCharacter } = Astro.props;

// Only create URLs if characters exist
const prevUrl = prevCharacter ? `/guides/horizon-walker/characters/${prevCharacter.slug}` : '#';
const nextUrl = nextCharacter ? `/guides/horizon-walker/characters/${nextCharacter.slug}` : '#';
---

<!-- Mobile Invisible Swipe Zones with visual indicators -->
<div
  class="mobile-swipe-zone mobile-swipe-left"
  data-direction="prev"
  data-character-url={prevUrl}
  aria-label={`Swipe right to go to ${prevCharacter?.name || 'previous'}`}
  role="button"
  tabindex="-1"
>
  <div class="swipe-indicator">
    <span class="swipe-arrow">‹</span>
  </div>
</div>
<div
  class="mobile-swipe-zone mobile-swipe-right"
  data-direction="next"
  data-character-url={nextUrl}
  aria-label={`Swipe left to go to ${nextCharacter?.name || 'next'}`}
  role="button"
  tabindex="-1"
>
  <div class="swipe-indicator">
    <span class="swipe-arrow">›</span>
  </div>
</div>

<!-- Mobile Navigation Buttons -->
<nav class="mobile-character-nav" aria-label="Character navigation">
  <a
    href={prevUrl}
    class="mobile-nav-button prev"
    aria-label={`Previous: ${prevCharacter?.name || 'None'}`}
  >
    <span class="nav-arrow">←</span>
    <span class="nav-label">Prev</span>
  </a>

  <a
    href="/guides/horizon-walker/characters/"
    class="mobile-nav-button center"
    aria-label="View all characters"
  >
    <span class="nav-label">All</span>
  </a>

  <a
    href={nextUrl}
    class="mobile-nav-button next"
    aria-label={`Next: ${nextCharacter?.name || 'None'}`}
  >
    <span class="nav-label">Next</span>
    <span class="nav-arrow">→</span>
  </a>
</nav>

<script>
  // AddEventListenerOptions type definition
  interface AddEventListenerOptions {
    capture?: boolean;
    once?: boolean;
    passive?: boolean;
    signal?: AbortSignal;
  }

  // Optimized mobile navigation for Horizon Walker
  class HWMobileNavigation {
    private touchStartX = 0;
    private touchStartY = 0;
    private touchStartTime = 0;
    private isSwiping = false;
    private swipeThreshold = 50;
    private velocityThreshold = 0.3;
    private abortController: AbortController | null = null;

    constructor() {
      this.init();
    }

    private init(): void {
      // Only initialize if we're on a character page
      const swipeZones = document.querySelectorAll('.mobile-swipe-zone');
      if (swipeZones.length === 0) return;

      // Create abort controller for cleanup
      this.abortController = new AbortController();
      const { signal } = this.abortController;

      // Use passive listeners for better performance
      const options: AddEventListenerOptions = {
        passive: true,
        signal,
      };

      // Add touch listeners only to swipe zones, not the entire document
      swipeZones.forEach(zone => {
        zone.addEventListener('touchstart', this.handleTouchStart.bind(this), options);
        zone.addEventListener('touchmove', this.handleTouchMove.bind(this), options);
        zone.addEventListener('touchend', this.handleTouchEnd.bind(this), options);
      });

      // Add keyboard navigation
      document.addEventListener('keydown', this.handleKeyboard.bind(this), { signal });

      // Cleanup on page navigation
      document.addEventListener('astro:before-swap', () => this.cleanup(), { once: true });
    }

    private handleTouchStart(e: TouchEvent): void {
      this.touchStartX = e.touches[0].clientX;
      this.touchStartY = e.touches[0].clientY;
      this.touchStartTime = Date.now();
      this.isSwiping = false;

      // Show visual feedback
      const zone = e.currentTarget as HTMLElement;
      zone.classList.add('active');
    }

    private handleTouchMove(e: TouchEvent): void {
      if (!this.touchStartX || !this.touchStartY) return;

      const deltaX = e.touches[0].clientX - this.touchStartX;
      const deltaY = e.touches[0].clientY - this.touchStartY;

      // Determine if this is a horizontal swipe
      if (!this.isSwiping) {
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
          this.isSwiping = true;
        }
      }
    }

    private handleTouchEnd(e: TouchEvent): void {
      const zone = e.currentTarget as HTMLElement;
      zone.classList.remove('active');

      if (!this.touchStartX || !this.touchStartY) return;

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const touchEndTime = Date.now();

      const deltaX = touchEndX - this.touchStartX;
      const deltaY = touchEndY - this.touchStartY;
      const deltaTime = touchEndTime - this.touchStartTime;
      const velocity = Math.abs(deltaX) / deltaTime;

      // Check if it's a valid horizontal swipe
      if (
        this.isSwiping &&
        Math.abs(deltaX) > Math.abs(deltaY) &&
        (Math.abs(deltaX) > this.swipeThreshold || velocity > this.velocityThreshold)
      ) {
        const url = zone.getAttribute('data-character-url');
        if (url) {
          // Add haptic feedback if available
          if ('vibrate' in navigator) {
            navigator.vibrate(10);
          }

          // Navigate with view transition if supported
          this.navigateWithTransition(url);
        }
      }

      // Reset
      this.touchStartX = 0;
      this.touchStartY = 0;
      this.isSwiping = false;
    }

    private handleKeyboard(e: KeyboardEvent): void {
      // Only handle arrow keys when not in an input field
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      const leftZone = document.querySelector('.mobile-swipe-left') as HTMLElement;
      const rightZone = document.querySelector('.mobile-swipe-right') as HTMLElement;

      if (e.key === 'ArrowLeft' && leftZone) {
        const url = leftZone.getAttribute('data-character-url');
        if (url) this.navigateWithTransition(url);
      } else if (e.key === 'ArrowRight' && rightZone) {
        const url = rightZone.getAttribute('data-character-url');
        if (url) this.navigateWithTransition(url);
      }
    }

    private navigateWithTransition(url: string): void {
      // Use View Transitions API if available
      if ('startViewTransition' in document) {
        (document as any).startViewTransition(() => {
          window.location.href = url;
        });
      } else {
        window.location.href = url;
      }
    }

    private cleanup(): void {
      // Abort all event listeners
      if (this.abortController) {
        this.abortController.abort();
        this.abortController = null;
      }
    }
  }

  // Initialize only once when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new HWMobileNavigation());
  } else {
    new HWMobileNavigation();
  }
</script>

<style>
  /* Mobile swipe zone visual indicators */
  .mobile-swipe-zone {
    position: fixed;
    top: 20%;
    bottom: 20%;
    width: 80px;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: pan-y;
  }

  .mobile-swipe-left {
    left: 0;
  }

  .mobile-swipe-right {
    right: 0;
  }

  .swipe-indicator {
    display: none;
    width: 40px;
    height: 40px;
    background: rgba(var(--hw-green-rgb, 34, 197, 94), 0.1);
    border-radius: 50%;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  }

  .mobile-swipe-zone.active .swipe-indicator {
    display: flex;
    background: rgba(var(--hw-green-rgb, 34, 197, 94), 0.2);
    transform: scale(1.2);
  }

  .swipe-arrow {
    color: var(--hw-green-500, #22c55e);
    font-size: 24px;
    font-weight: bold;
  }

  /* Show indicators on hover for debugging */
  @media (hover: hover) {
    .mobile-swipe-zone:hover .swipe-indicator {
      display: flex;
    }
  }

  /* Hide on desktop */
  @media (min-width: 769px) {
    .mobile-swipe-zone,
    .mobile-character-nav {
      display: none !important;
    }
  }
</style>
